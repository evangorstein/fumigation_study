---
title: "Network Analysis New Fungi"
author: "Tianyi Xu"
date: "2025-03-07"
output: html_document
---

```{r}
#installation in case you need some package
#install.packages(c("igraph", "graphlayouts", "ggraph","ggforce"))
#devtools::install_github("schochastics/networkdata")
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(vegan)
library(tidyverse)
library(here)
library(forcats)
library(compositions)
library(dplyr)
library(stringr)
library(glasso)
library(igraph)
library(qgraph)
library(ggraph)
library(networkdata)
library(graphlayouts)
library(ggforce)
library(ggplot2)
library(CARlasso)
library(viridis)
library(VennDiagram)
library(ggsci)
library(RColorBrewer)
```

Read in the data

```{r}
samp_metadata = readRDS(here("data", "clean", "samp_metadata.RDS"))
fung_abundance = readRDS(here("data", "clean", "fung_abundance.RDS"))
```

Data Preprocessing
    
```{r}
# Aggregate based on families. Choose to look at family OTU.
genus.df = fung_abundance %>% 
  mutate(Genus = as.character(Genus), Species = as.character(Species)) %>%
  mutate(Genus = ifelse(Genus == "Unknown_Genus", Species, Genus)) %>%
  mutate(Genus = replace_na(Genus, "Unknown")) %>% #Missing values included in Unknown level
  group_by(Genus) %>%
  summarise(across(starts_with("Samp"), sum)) 

genus = genus.df$Genus
genus.mat = as.matrix(genus.df[,-1])
rownames(genus.mat) = genus
genus.mat = genus.mat[rownames(genus.mat)!="Unknown",]
genus.mat = t(genus.mat)

```

Extract the phylum mapping for each family
```{r}
phylum_mapping = fung_abundance %>%
  select(Genus, Phylum) %>%
  mutate(Phylum = as.character(Phylum), Genus = as.character(Genus)) %>%
  mutate(Phylum = replace_na(Phylum, "Unknown")) %>%
  group_by(Genus) %>%
  summarise(Phylum = first(Phylum)) %>%
  {setNames(.$Phylum, .$Genus)}
```

```{r}
# add sample number to metadata for each samples.
samp_metadata = samp_metadata %>%
  mutate(fumigation = case_when(
    Time == "Day_0" | Treatment == "Non-fumigated chipping grass"  ~ "never",
    Time == "Day_10" & Treatment != "Non-fumigated chipping grass" ~ "recent",
    Time != "Day_0" & Time != "Day_10" & Treatment != "Non-fumigated chipping grass" ~ "past"
  )) %>%
  mutate(sample_name = case_when(
    samp_number < 10 ~ paste0("Samp00", samp_number),
    samp_number < 100 ~ paste0("Samp0", samp_number),
    TRUE ~ paste0("Samp", samp_number)
  ))
```

```{r}
# pull out samples based on fumigation time
never = samp_metadata %>% filter(fumigation == "never") %>% pull(sample_name)
recent = samp_metadata %>% filter(fumigation == "recent") %>% pull(sample_name)
past = samp_metadata %>% filter(fumigation == "past") %>% pull(sample_name)

# create 3 different matrix for 3 fumigation time
genus.mat.never = genus.mat[never,]
genus.mat.recent = genus.mat[recent,]
genus.mat.past = genus.mat[past,]
```

Function for data analysis

```{r}
# create a function to process matrix
create_matrix = function(mat){
    # clr transformation
    mat = mat + 0.5
    mat = clr(mat)

    # correlation matrix
    mat = cor(mat)
    return(mat)
}

glasso_net = function(mat, rho){
    net = glasso(mat, rho = rho)
    p.net = net$wi
    colnames(p.net) = colnames(mat)
    rownames(p.net) = rownames(mat)

    # check if matrix is symmetric
    if (!isSymmetric(p.net)) {
        p.net[lower.tri(p.net)] = t(p.net)[lower.tri(p.net)]
    }

    # calculate partical correlation matrix
    parr.corr.net = matrix(nrow = nrow(p.net), ncol = ncol(p.net))

    for(k in 1:nrow(parr.corr.net)) {
        for(j in 1:ncol(parr.corr.net)) {
        parr.corr.net[j, k] = -p.net[j,k]/sqrt(p.net[j,j]*p.net[k,k])
        }
    }

    colnames(parr.corr.net) = colnames(p.net)
    rownames(parr.corr.net) = rownames(p.net)
    diag(parr.corr.net) = 0

    net.glasso = graph.adjacency(parr.corr.net, mode = "undirected", weighted = TRUE, diag = FALSE)
    return(net.glasso)
}   
```

Set scale_edge_color_discrete

```{r}
set.seed(3407)
```

Plot the network - Glasso

```{r}
# first get transformed matrix
never.mat = create_matrix(genus.mat.never)
recent.mat = create_matrix(genus.mat.recent)
past.mat = create_matrix(genus.mat.past)

never.glasso = glasso_net(never.mat, 0.75)
recent.glasso = glasso_net(recent.mat, 0.75)
past.glasso = glasso_net(past.mat, 0.75)
```


```{r}

# convert glasso weight to positive
E(never.glasso)$positive_weight = E(never.glasso)$weight - (min(E(never.glasso)$weight)) + 0.0001
E(recent.glasso)$positive_weight = E(recent.glasso)$weight - (min(E(recent.glasso)$weight)) + 0.0001
E(past.glasso)$positive_weight = E(past.glasso)$weight - (min(E(past.glasso)$weight)) + 0.0001

# absolute weight
E(never.glasso)$abs_weight = abs(E(never.glasso)$weight)
E(recent.glasso)$abs_weight = abs(E(recent.glasso)$weight)
E(past.glasso)$abs_weight = abs(E(past.glasso)$weight)
```

```{r}
# # compute clustering
# V(never.glasso)$clu = as.character(membership(cluster_louvain(never.glasso)))
# V(recent.glasso)$clu = as.character(membership(cluster_louvain(recent.glasso)))
# V(past.glasso)$clu = as.character(membership(cluster_louvain(past.glasso)))

# compute node size based on degree
V(never.glasso)$size = degree(never.glasso)
V(recent.glasso)$size = degree(recent.glasso)
V(past.glasso)$size = degree(past.glasso)

# V(never.glasso)$clu[V(never.glasso)$degree == 0] = "999"
# V(recent.glasso)$clu[V(recent.glasso)$degree == 0] = "999"
# V(past.glasso)$clu[V(past.glasso)$degree == 0] = "999"
```

```{r}
# Find nodes with a degree of 0 for each graph
zero_degree_nodes_never = V(never.glasso)[degree(never.glasso) == 0]
zero_degree_nodes_recent = V(recent.glasso)[degree(recent.glasso) == 0]
zero_degree_nodes_past = V(past.glasso)[degree(past.glasso) == 0]

# Assign these nodes to a new community cluster (cluster "999")
V(never.glasso)[degree(never.glasso) == 0]$clu = "999"
V(recent.glasso)[degree(recent.glasso) == 0]$clu = "999"
V(past.glasso)[degree(past.glasso) == 0]$clu = "999"
```

Plot the network for Glasso method

Here is the function to create a plot.

```{r}
# # net: net object, title: title of plot, filter: filter out nodes with degree less than filter
plot_circular_network = function(net, title, phylum_mapping,degree_filter, node_size = 3, edge_threshold = 0.07){
  # filter out edges
    net_filtered = delete_edges(net, which(E(net)$abs_weight <= edge_threshold))
    base_colors = pal_npg("nrc")(10)
    phylum_colors = colorRampPalette(base_colors)(27)  # Repeat for 27 phyla

    # add phylum information to nodes
    V(net_filtered)$phylum = phylum_mapping[V(net_filtered)$name]
    V(net_filtered)$phylum[is.na(V(net_filtered)$phylum)] = "Unknown_Phylum"

    # order nodes by phylum
    V(net_filtered)$phylum = factor(V(net_filtered)$phylum, levels = sort(unique(V(net_filtered)$phylum)))
    net_filtered = permute(net_filtered, order(V(net_filtered)$phylum))

    # add edge color
    E(net_filtered)$edge_color = ifelse(E(net_filtered)$weight >= 0, "#D73027", "#4575B4") 
    # assign edge alpha
    E(net_filtered)$edge_alpha = scales::rescale(E(net_filtered)$abs_weight, to = c(0.3, 0.8))

    layout_data = create_layout(net_filtered, layout = "circle")

    network = ggraph(layout_data) +
    geom_edge_link0(aes(width = weight, alpha = edge_alpha, color = edge_color)) +
    geom_node_point(aes(fill = phylum), shape = 21, size = node_size, stroke = 0.8) +
    geom_node_text(aes(filter = size > degree_filter, label = name, size = 3), family = "serif", repel = TRUE, show.legend = FALSE) +
    scale_edge_width(range = c(0.5, 2.5)) +
    scale_edge_alpha(range = c(0.3, 0.8)) +
    scale_edge_color_identity() +
    #scale_size(range = c(1, 6)) +
    #scale_fill_viridis(discrete = TRUE, option = "viridis", name = "phylum") +
    scale_fill_manual(values = phylum_colors, name = "Phylum") +
    labs(fill = "Phylum") +  # Renames legend titles properly
        guides(
          edge_alpha = "none",
          edge_width = "none",
            fill = guide_legend(title = "Phylum")
        ) +
    theme_void() +
    theme(
      legend.position = "right",
      plot.background = element_rect(fill = "white", color = NA),  # White background for the entire plot
      legend.text = element_text(size = 10, family = "Times New Roman"),
      legend.title = element_text(size = 12, family = "Times New Roman", face = "bold")
    )
    return(network)
}
```

We do a little investigation to choose the edge threshold.

```{r}
# Extract edge weights from all three networks
edge_weights_never = E(never.glasso)$abs_weight
edge_weights_recent = E(recent.glasso)$abs_weight
edge_weights_past = E(past.glasso)$abs_weight

# df for edge weights
#all_edge_weights = c(edge_weights_never, edge_weights_recent, edge_weights_past)

edge_weights_never_df = data.frame(weight = edge_weights_never)
edge_weights_recent_df = data.frame(weight = edge_weights_recent)
edge_weights_past_df = data.frame(weight = edge_weights_past)
```

```{r}
# plot the distribution of edge weights for never fumigated samples
ggplot(edge_weights_never_df, aes(x = weight)) +
    geom_histogram(bins = 50, fill = "steelblue", alpha = 0.7) +
    geom_vline(xintercept = quantile(edge_weights_never_df$weight, c(0.75, 0.9, 0.95)), 
               linetype = "dashed", color = "red") +
    theme_minimal() +
    labs(title = "Edge Weight Distribution for Never Fumigated Samples", x = "Edge Weight", y = "Count")
```

```{r}
# plot the distribution of edge weights for recent fumigated samples
ggplot(edge_weights_recent_df, aes(x = weight)) +
    geom_histogram(bins = 50, fill = "steelblue", alpha = 0.7) +
    geom_vline(xintercept = quantile(edge_weights_recent_df$weight, c(0.75, 0.9, 0.95)), 
               linetype = "dashed", color = "red") +
    theme_minimal() +
    labs(title = "Edge Weight Distribution for Recent Fumigated Samples", x = "Edge Weight", y = "Count")
```

```{r}
# plot the distribution of edge weights for past fumigated samples
ggplot(edge_weights_past_df, aes(x = weight)) +
    geom_histogram(bins = 50, fill = "steelblue", alpha = 0.7) +
    geom_vline(xintercept = quantile(edge_weights_past_df$weight, c(0.75, 0.9, 0.95)), 
               linetype = "dashed", color = "red") +
    theme_minimal() +
    labs(title = "Edge Weight Distribution for Past Fumigated Samples", x = "Edge Weight", y = "Count")
```

We choose the threshold for each fumigation time.

We choose 0.9 quantile as the edge threshold.

```{r}
egde_threshold_never = quantile(edge_weights_never_df$weight, 0.9)
egde_threshold_recent = quantile(edge_weights_recent_df$weight, 0.9)
egde_threshold_past = quantile(edge_weights_past_df$weight, 0.9)
print(paste("The edge threshold for never fumigated samples is", egde_threshold_never))
print(paste("The edge threshold for recent fumigated samples is", egde_threshold_recent))
print(paste("The edge threshold for past fumigated samples is", egde_threshold_past))
```

```{r}
# plot the network for glasso

#never
plot.never.glasso = plot_circular_network(never.glasso, "Network for Never Fumigated Samples Using Glasso", phylum_mapping, 999, edge_threshold = egde_threshold_never)
plot.never.glasso

ggsave("plot_circular/fungi/never_glasso.pdf", plot.never.glasso, width = 12, height = 10, dpi = 600, device = cairo_pdf, bg = "white", limitsize = FALSE)
```


```{r}
# recent
plot.recent.glasso = plot_circular_network(recent.glasso, "Network for Recent Fumigated Samples Using Glasso", phylum_mapping, 999, edge_threshold = egde_threshold_recent)
plot.recent.glasso

ggsave("plot_circular/fungi/recent_glasso.pdf", plot.recent.glasso, width = 12, height = 10, dpi = 600, device = cairo_pdf, bg = "white", limitsize = FALSE)
```


```{r}
# past
plot.past.glasso = plot_circular_network(past.glasso, "Network for Past Fumigated Samples Using Glasso", phylum_mapping, 999, edge_threshold = egde_threshold_past)
plot.past.glasso

ggsave("plot_circular/fungi/past_glasso.pdf", plot.past.glasso, width = 12, height = 10, dpi = 600, device = cairo_pdf, bg = "white", limitsize = FALSE)
```


Now, find intersection of edges between the 3 networks.

```{r}
# function to create a venn diagram for 3 networks
create_triple_venn = function(net1, net2, net3, names) {
  # Get edge lists and standardize them
  edges1 = get.edgelist(net1)
  edges2 = get.edgelist(net2)
  edges3 = get.edgelist(net3)
  
  # Sort each edge to ensure consistent representation
  edges1 = t(apply(edges1, 1, sort))
  edges2 = t(apply(edges2, 1, sort))
  edges3 = t(apply(edges3, 1, sort))
  
  # Convert to dataframes for easier comparison
  edges1_df = as.data.frame(edges1)
  edges2_df = as.data.frame(edges2)
  edges3_df = as.data.frame(edges3)
  
  # Create a unique identifier for each edge
  edges1_df$edge_id = paste(edges1_df$V1, edges1_df$V2, sep = "_")
  edges2_df$edge_id = paste(edges2_df$V1, edges2_df$V2, sep = "_")
  edges3_df$edge_id = paste(edges3_df$V1, edges3_df$V2, sep = "_")
  
  # Get unique edge IDs for each network
  edges_set1 = edges1_df$edge_id
  edges_set2 = edges2_df$edge_id
  edges_set3 = edges3_df$edge_id
  
  # Create the Venn diagram
  venn_plot = draw.triple.venn(
    area1 = length(edges_set1),
    area2 = length(edges_set2),
    area3 = length(edges_set3),
    n12 = length(intersect(edges_set1, edges_set2)),
    n23 = length(intersect(edges_set2, edges_set3)),
    n13 = length(intersect(edges_set1, edges_set3)),
    n123 = length(intersect(intersect(edges_set1, edges_set2), edges_set3)),
    category = c(
      paste0(names[1], " (", length(edges_set1), ")"),
      paste0(names[2], " (", length(edges_set2), ")"),
      paste0(names[3], " (", length(edges_set3), ")")
    ),
    fill = c("#1B9E77", "#D95F02", "#7570B3"),
    alpha = 0.5,
    lty = "solid",
    cex = 3.5,
    cat.cex = 2.4,
    cat.dist = 0.05,
    cat.pos = c(0, 0, 180)
  )
  
  return(venn_plot)
}
```

Plot the venn diagram for the 3 networks

```{r}
venn_plot = create_triple_venn(never.glasso, recent.glasso, past.glasso, c("Never", "Recent", "Past"))
grid.draw(venn_plot)
```

```{r}
options(repr.plot.res = 1200)    # Set global resolution to 1200 DPI
par(mar = c(5, 4, 4, 2) + 0.1)  # Adjust margins for high-res output

cairo_pdf(here("plot_circular", "fungi", "venn_plot.pdf"), 
    width = 12, 
    height = 15,
    family = "ArialMT",
    fallback_resolution = 1200,  # Set DPI to 1200
    onefile = TRUE)
grid.draw(venn_plot)
dev.off()
```

Draw the network for edges in all 3 networks

```{r}
# Function to create and plot a network with edges common to all three networks
plot_common_edges_network = function(net1, net2, net3, title, phylum_mapping, node_size = 10, edge_threshold = 0.07) {
  # Get edge lists and standardize them
  edges1 = get.edgelist(net1)
  edges2 = get.edgelist(net2)
  edges3 = get.edgelist(net3)
  
  # Sort each edge to ensure consistent representation
  edges1 = t(apply(edges1, 1, sort))
  edges2 = t(apply(edges2, 1, sort))
  edges3 = t(apply(edges3, 1, sort))
  
  # Convert to dataframes for easier comparison
  edges1_df = as.data.frame(edges1)
  edges2_df = as.data.frame(edges2)
  edges3_df = as.data.frame(edges3)
  
  # Create a unique identifier for each edge
  edges1_df$edge_id = paste(edges1_df$V1, edges1_df$V2, sep = "_")
  edges2_df$edge_id = paste(edges2_df$V1, edges2_df$V2, sep = "_")
  edges3_df$edge_id = paste(edges3_df$V1, edges3_df$V2, sep = "_")
  
  # Find edges common to all three networks
  common_edges_ids = intersect(intersect(edges1_df$edge_id, edges2_df$edge_id), edges3_df$edge_id)
  
  # Extract the common edges
  common_edges = edges1_df[edges1_df$edge_id %in% common_edges_ids, c("V1", "V2")]
  
  # Create a new graph with only the common edges
  # First, identify all unique nodes in the common edges
  all_nodes = unique(c(common_edges$V1, common_edges$V2))
  
  # Create an empty graph
  common_graph = graph.empty(directed = FALSE, n = length(all_nodes))
  V(common_graph)$name = all_nodes
  
  # Add the common edges
  common_graph = add_edges(common_graph, t(as.matrix(common_edges)))
  
  # Add phylum information to nodes
  V(common_graph)$phylum = phylum_mapping[V(common_graph)$name]
  V(common_graph)$phylum[is.na(V(common_graph)$phylum)] = "Unknown_Phylum"
  
  # Calculate node degree for sizing text
  V(common_graph)$degree = degree(common_graph)

  # filter out edges with weight less than edge_threshold
  #common_graph = delete_edges(common_graph, which(E(common_graph)$weight <= edge_threshold))

  phylum_colors = pal_npg("nrc")(10)
  #phylum_colors = colorRampPalette(base_colors)(10)


  # #Assign edge colors by blending both connected node colors
  # E(common_graph)$edge_color = sapply(1:ecount(common_graph), function(i) {
  #   edge_ends = ends(common_graph, i)
  #   node1_phylum = V(common_graph)$phylum[match(edge_ends[1], V(common_graph)$name)]
  #   node2_phylum = V(common_graph)$phylum[match(edge_ends[2], V(common_graph)$name)]

  #   # Get phylum color indices
  #   index1 = match(node1_phylum, unique(V(common_graph)$phylum))
  #   index2 = match(node2_phylum, unique(V(common_graph)$phylum))

  #   # Handle missing indices
  #   if (is.na(index1)) index1 = 1
  #   if (is.na(index2)) index2 = 1

  #   # Get colors for both nodes
  #   color1 = col2rgb(phylum_colors[index1])
  #   color2 = col2rgb(phylum_colors[index2])
    
  #   # Compute blended color
  #   avg_color = rgb((color1[1] + color2[1]) / 2 / 255, 
  #                   (color1[2] + color2[2]) / 2 / 255, 
  #                   (color1[3] + color2[3]) / 2 / 255)
    
  #   return(avg_color)
  # })
  #E(common_graph)$edge_alpha = scales::rescale(E(common_graph)$weight, to = c(0.3, 0.8))
  # Create the plot
  network_plot = ggraph(common_graph, layout = "circle") +
    geom_edge_link0(aes(color = "#FDAE61")) +
    geom_node_point(aes(fill = phylum), shape = 21, size = node_size, stroke = 0.8) +
    geom_node_text(aes(label = name, size = 5, x = 1.1*x, y = 1.1*y, repel = TRUE), 
                  family = "serif", repel = TRUE, show.legend = FALSE) +
    #scale_size(range = c(2, 5)) +
    #scale_fill_viridis(discrete = TRUE, option = "viridis", name = "Phylum") +
    scale_edge_width(range = c(0.5, 2.5)) +
    #scale_edge_alpha(range = c(0.3, 0.8)) +
    scale_edge_color_identity() +
    scale_fill_manual(values = phylum_colors, name = "Phylum") +
    labs(
        fill = "Phylum") +  # Renames legend titles properly
    guides(
        edge_alpha = "none",
        edge_width = "none",
        fill = guide_legend(title = "Phylum")
    ) +
    theme_graph() +
    ggtitle(title) +
    theme(
      plot.title = element_text(size = 18, face = "bold", family = "Times", hjust = 0.5),
      legend.position = "right",
      legend.title = element_text(size = 12, face = "bold"),
      legend.text = element_text(size = 10),
      plot.background = element_rect(fill = "white", color = NA)
    )
  return(list(plot = network_plot, graph = common_graph))
}
```

```{r}
#Now use the function for each fumigation condition
never_common_result = plot_common_edges_network(
  never.glasso, recent.glasso, past.glasso,
  "Subnetwork Shared Among All Three Fumigation Status",
  phylum_mapping
)

# Display the plot
never_common_result$plot

# Save the plot
ggsave("plot_circular/fungi/never_common_edges.pdf", 
       never_common_result$plot, 
       width = 12, height = 10, dpi = 600, 
       device = cairo_pdf, bg = "white", limitsize = FALSE)

```

Now, unique edges in each network.

```{r}
# Optimized function to create and plot networks with edges unique to each method
plot_unique_edges_network = function(net1, net2, net3, method_names, title, phylum_mapping, node_size = 10) {
  # Get edge lists and standardize them
  edges1 = get.edgelist(net1)
  edges2 = get.edgelist(net2)
  edges3 = get.edgelist(net3)
  
  # Sort each edge to ensure consistent representation
  edges1 = t(apply(edges1, 1, sort))
  edges2 = t(apply(edges2, 1, sort))
  edges3 = t(apply(edges3, 1, sort))
  
  # Convert to dataframes for easier comparison
  edges1_df = as.data.frame(edges1)
  edges2_df = as.data.frame(edges2)
  edges3_df = as.data.frame(edges3)
  
  # Create a unique identifier for each edge
  edges1_df$edge_id = paste(edges1_df$V1, edges1_df$V2, sep = "_")
  edges2_df$edge_id = paste(edges2_df$V1, edges2_df$V2, sep = "_")
  edges3_df$edge_id = paste(edges3_df$V1, edges3_df$V2, sep = "_")
  
  # Add weights to the edge dataframes
  edges1_df$weight = E(net1)$weight
  edges2_df$weight = E(net2)$weight
  edges3_df$weight = E(net3)$weight

  # add absolute weight
  edges1_df$abs_weight = abs(edges1_df$weight)
  edges2_df$abs_weight = abs(edges2_df$weight)
  edges3_df$abs_weight = abs(edges3_df$weight)
  
  # Find edges unique to each network
  unique_edges1 = setdiff(edges1_df$edge_id, union(edges2_df$edge_id, edges3_df$edge_id))
  unique_edges2 = setdiff(edges2_df$edge_id, union(edges1_df$edge_id, edges3_df$edge_id))
  unique_edges3 = setdiff(edges3_df$edge_id, union(edges1_df$edge_id, edges2_df$edge_id))
  
  # Create a list to store the three networks
  unique_networks = list()
  plots = list()
  
  # Colors for each method
  method_colors = c("#1B9E77", "#D95F02", "#7570B3")
  
  # Process each network
  for (i in 1:3) {
    # Get the appropriate unique edges
    if (i == 1) {
      unique_edges = unique_edges1
      edges_df = edges1_df
    } else if (i == 2) {
      unique_edges = unique_edges2
      edges_df = edges2_df
    } else {
      unique_edges = unique_edges3
      edges_df = edges3_df
    }
    
    # Skip if no unique edges
    if (length(unique_edges) == 0) {
      unique_networks[[i]] = NULL
      plots[[i]] = NULL
      next
    }
    
    # Extract edges and weights
    unique_edges_df = edges_df[edges_df$edge_id %in% unique_edges, ]
    
    # Filter by weight threshold
    # dynamic edge threshold
    edge_threshold = quantile(unique_edges_df$abs_weight, 0.9)
    unique_edges_df = unique_edges_df[unique_edges_df$abs_weight > edge_threshold, ]
    
    # Skip if no edges after filtering
    if (nrow(unique_edges_df) == 0) {
      unique_networks[[i]] = NULL
      plots[[i]] = NULL
      next
    }
    
    # Create a new graph with only the unique edges
    all_nodes = unique(c(unique_edges_df$V1, unique_edges_df$V2))
    
    # Create an empty graph
    unique_graph = graph.empty(directed = FALSE, n = length(all_nodes))
    V(unique_graph)$name = all_nodes
    
    # Add the unique edges with weights
    for (j in 1:nrow(unique_edges_df)) {
      unique_graph = add_edges(
        unique_graph, 
        c(unique_edges_df$V1[j], unique_edges_df$V2[j]),
        weight = unique_edges_df$weight[j]
      )
    }
    
    # Add phylum information to nodes
    V(unique_graph)$phylum = phylum_mapping[V(unique_graph)$name]
    V(unique_graph)$phylum[is.na(V(unique_graph)$phylum)] = "Unknown_Phylum"
    
    # Calculate node degree for sizing text
    V(unique_graph)$degree = degree(unique_graph)
    
    # Store the graph
    unique_networks[[i]] = unique_graph

    unique_phylums_num = length(unique(V(unique_graph)$phylum))
    if (unique_phylums_num > 10) {
      base_colors = pal_npg("nrc")(10)
      phylum_colors = colorRampPalette(base_colors)(unique_phylums_num)
    } else {
      phylum_colors = pal_npg("nrc")(unique_phylums_num)
    }
    # Assign edge colors
    E(unique_graph)$edge_color = ifelse(E(unique_graph)$weight > 0, "#D73027", "#4575B4")
   
    E(unique_graph)$edge_alpha = scales::rescale(E(unique_graph)$weight, to = c(0.3, 0.8))
    
    # Create the plot
    network_plot = ggraph(unique_graph, layout = "circle") +
      geom_edge_link0(aes(width = weight, alpha = edge_alpha, color = edge_color)) +
      scale_edge_width(range = c(0.2, 3)) +
      scale_edge_alpha(range = c(0.3, 0.8)) +
      scale_edge_color_identity() +
      geom_node_point(aes(fill = phylum), shape = 21, size = node_size, stroke = 0.8) +
      geom_node_text(aes(label = name, size = 4, x = 1.1*x, y = 1.1*y, repel = TRUE), 
                    family = "serif", repel = TRUE, show.legend = FALSE) +
      #scale_size(range = c(2, 5)) +
      scale_fill_manual(values = phylum_colors, name = "Phylum") +
      labs(
           fill = "Phylum") +  
      guides(
        edge_alpha = "none",
        edge_width = "none",
        fill = guide_legend(title = "Phylum")
      ) +
      theme_graph() +
      ggtitle(paste0("Subnetwork Specific to ", method_names[i], " Fumigation Status")) +
      theme(
        plot.title = element_text(size = 16, hjust = 0.5),
        legend.position = "right",
        legend.title = element_text(size = 12, face = "bold", family = "Times"),
        legend.text = element_text(size = 10, family = "Times"),
        plot.background = element_rect(fill = "white", color = NA)
      )
    
    plots[[i]] = network_plot
  }
  
  return(list(plots = plots, graphs = unique_networks))
}
```

Plot the unique networks

```{r}

# Now use the function for each fumigation condition
# For never fumigated samples
unique_result = plot_unique_edges_network(
  never.glasso, recent.glasso, past.glasso,
  c("Never", "Recent", "Past"),
  "Edges Unique to Each Fumigation Condition",
  phylum_mapping
)
```

```{r}
# Display and save the plots
for (i in 1:3) {
  if (!is.null(unique_result$plots[[i]])) {
    print(unique_result$plots[[i]])
    method_name = c("Never", "Recent", "Past")[i]
    ggsave(paste0("plot_circular/fungi/never_unique_", method_name, ".pdf"), 
           unique_result$plots[[i]], 
           width = 12, height = 10, dpi = 600, 
           device = cairo_pdf, bg = "white", limitsize = FALSE)
  }
}
```

Now, Identify Different nodes/taxas in 3 network.

```{r}
# degree and betweenness centrality
degree.never = degree(never.glasso)
degree.recent = degree(recent.glasso)
degree.past = degree(past.glasso)

betweenness.never = betweenness(never.glasso)
betweenness.recent = betweenness(recent.glasso)
betweenness.past = betweenness(past.glasso)
```

```{r}
# df
degree_df = data.frame(
  fumigation = c(rep("never", length(degree.never)), rep("recent", length(degree.recent)), rep("past", length(degree.past))),
  degree = c(degree.never, degree.recent, degree.past)
)

betweenness_df = data.frame(
  fumigation = c(rep("never", length(betweenness.never)), rep("recent", length(betweenness.recent)), rep("past", length(betweenness.past))),
  betweenness = c(betweenness.never, betweenness.recent, betweenness.past)
)
```

Plot the degree and betweenness centrality

```{r}
# degree
dg_boxplot = ggplot(degree_df, aes(x = fumigation, y = degree)) +
  geom_boxplot() +
  theme_minimal() +
  labs(x = "Fumigation Status", y = "Degree Distribution", title = "Combined Graph") +
  theme(
    plot.title = element_text(size = 25, hjust = 0.5),  # Increase the size of the plot title
    axis.title.x = element_text(size = 20, margin = margin(t = 15)),  # Increase the size of the x-axis title
    axis.title.y = element_text(size = 30, margin = margin(r = 15)),  # Increase the size of the y-axis title
    axis.text.x = element_text(size = 25),  # Increase the size of the x-axis labels
    axis.text.y = element_text(size = 25)   # Increase the size of the y-axis labels
  )

dg_boxplot

ggsave("plot_circular/fungi/dg_boxplot.pdf", dg_boxplot, width = 12, height = 10, dpi = 600, device = cairo_pdf, bg = "white", limitsize = FALSE)
```

```{r}
# betweenness
bt_boxplot = ggplot(betweenness_df, aes(x = fumigation, y = betweenness)) +
  geom_boxplot() +
  theme_minimal() +
  labs(x = "Fumigation Status", y = "Betweenness Distribution", title = "Combined Graph") +
  theme(
    plot.title = element_text(size = 25, hjust = 0.5),  # Increase the size of the plot title
    axis.title.x = element_text(size = 20, margin = margin(t = 15)),  # Increase the size of the x-axis title
    axis.title.y = element_text(size = 30, margin = margin(r = 15)),  # Increase the size of the y-axis title
    axis.text.x = element_text(size = 25),  # Increase the size of the x-axis labels
    axis.text.y = element_text(size = 25)   # Increase the size of the y-axis labels
  )

bt_boxplot

ggsave("plot_circular/fungi/bt_boxplot.pdf", bt_boxplot, width = 12, height = 10, dpi = 600, device = cairo_pdf, bg = "white", limitsize = FALSE)
```

Let's find the 20 most different one

```{r}
# degree
degree_difference = abs(degree.never - degree.recent) + abs(degree.never - degree.past) + abs(degree.recent - degree.past)
betweeness_difference = abs(betweenness.never - betweenness.recent) + abs(betweenness.never - betweenness.past) + abs(betweenness.recent - betweenness.past)

difference_df = data.frame(
  names = names(degree_difference),
  degree_difference = degree_difference,
  betweeness_difference = betweeness_difference
)


difference_df$score = difference_df$degree_difference + difference_df$betweeness_difference

difference_df = difference_df[order(difference_df$score, decreasing = TRUE),]

top_20 = difference_df[1:20,]

top_20$names
```
Here is the names of the top 20 different nodes.

Now, we fit carlasso model to 20 taxas.

```{r}
never_fumigated = samp_metadata %>% 
  filter(fumigation == "never") %>%
  pull(sample_name)

recent_fumigated = samp_metadata %>%
  filter(fumigation == "recent") %>%
  pull(sample_name)

past_fumigated = samp_metadata %>%
  filter(fumigation == "past") %>%
  pull(sample_name)

genus_df = as.data.frame(genus.mat)
genus_df = genus_df %>%
  mutate(sample_name = rownames(genus_df)) %>%
  mutate(fumigation_status = case_when(
    sample_name %in% never_fumigated ~ "never",
    sample_name %in% recent_fumigated ~ "recent",
    sample_name %in% past_fumigated ~ "past"
  ))
genus_df$Treatment = samp_metadata$Treatment

otus = top_20$names
otu_quoted = paste0("`", otus, "`")
formula = paste(otu_quoted, collapse = "+")
formula_both = paste(formula, "~ fumigation_status+Treatment")
formula_both = as.formula(formula_both)
```


```{r}
# carlasso plot function, from sourcecode of CARlasso package

get_CAR_MB <- function(B, Omega) {
  D <- diag(diag(Omega))
  R <- D - Omega

  return(list(
    M = diag(1 / diag(Omega)),
    C = t(solve(D, R)), B = t(solve(D, t(B)))
  ))
}

custom_plot_carlasso <- function(x, text_size = 15, ...) {
    dots <- list(...)
    tol <- dots$tol
    if(x$settings$link=="logit"){
        response_name <- x$nodes$response[-length(x$nodes$response)]
    }
    else{
        response_name <- x$nodes$response
    }
    if(is.null(tol)) tol = 0.01
    col_pn <- c("lightblue","pink")
    # graph structure using threshold:
    if(is.null(x$horseshoe_binary)){
        B_binary <- abs(x$point_est$beta) > tol
        Graph_binary <- abs(x$point_est$Omega) > tol
    }
    else {
        B_binary <- x$horseshoe_binary$B_binary
        Graph_binary <- x$horseshoe_binary$Omega_binary
    }
    diag(Graph_binary) <- 1
    CAR <- get_CAR_MB(x$point_est$beta*B_binary,
        Graph_binary*x$point_est$Omega)
    
    n_resp <- length(response_name)
    n_pred <- length(x$nodes$predictors)

    vertices_df <- data.frame(id = c(paste0("resp", 1:n_resp), 
        paste0("pred", 1:n_pred)),
        group = c(rep("resp", n_resp),
        rep("pred", n_pred)))

    ind_mat_resp <- expand.grid(from = 1:n_resp, to = 1:n_resp)
    ind_mat_resp <- ind_mat_resp[ind_mat_resp$from != ind_mat_resp$to, ]
    ind_mat_resp$weight <- sapply(1:nrow(ind_mat_resp),
            function(i, indmat, mat) {
                mat[indmat$from[i], indmat$to[i]]
            }
        ,ind_mat_resp, CAR$C)

    ind_mat_pred <- expand.grid(from = 1:n_pred, to = 1:n_resp)
    ind_mat_pred$weight <- sapply(1:nrow(ind_mat_pred), 
            function(i, indmat, mat) {
                mat[indmat$from[i], indmat$to[i]]
            }
        , ind_mat_pred, CAR$B)

    ind_mat_pred$from <- paste0("pred", ind_mat_pred$from)
    ind_mat_pred$to <- paste0("resp", ind_mat_pred$to)
    ind_mat_resp$from <- paste0("resp", ind_mat_resp$from)
    ind_mat_resp$to <- paste0("resp", ind_mat_resp$to)

    edge_df <- rbind(ind_mat_resp, ind_mat_pred)
    edge_df <- edge_df[edge_df$weight != 0, ]

    edge_abs_df <- edge_df
    edge_abs_df$weight <- abs(edge_abs_df$weight)

    full_graph <- graph.data.frame(edge_df, vertices_df, directed = T)


    col_ER <- c("orange", "darkgreen")
    shape_ER <- c("square", "circle")
    type <- c("predictors", "microbe")
    direction <- c("negative", "positive")

    E(full_graph)$edge.color <- col_pn[(sign(E(full_graph)$weight) + 1) / 2 + 1]
    E(full_graph)$direction. <- direction[(sign(E(full_graph)$weight) + 1) / 2 + 1]
    E(full_graph)$abs_weight <- abs(E(full_graph)$weight)


    V(full_graph)$name <- c(response_name, x$nodes$predictors)

    V(full_graph)$alpha_centrality <- alpha_centrality(full_graph)
    V(full_graph)$type <- type[c(rep(2, n_resp), rep(1, n_pred))]

    cbPalette_edge <- c("#0072B2", "#990000")
    cbPalette_node <- c("#0815d3", "#682d01")

    set_graph_style(plot_margin = margin(10, 10, 10, 10))
    p <- ggraph(full_graph, layout = "circle") 
    
    if(length(unique(E(full_graph)$direction.))==1){
        p <- p + geom_edge_link(aes(
            width = abs_weight, alpha = abs_weight), 
            color = ifelse(E(full_graph)$direction.[1]=="positive",cbPalette_edge[2], cbPalette_edge[1]))
    }
    else {
       p <- p + geom_edge_link(aes(color = direction.,
            width = abs_weight, alpha = abs_weight)) +
        scale_edge_color_manual(values = (cbPalette_edge))
    }
    
    p <-  p +
        geom_node_point(mapping = aes(shape = type,
                size = alpha_centrality, stroke = 1.5),
            col = "#000000", fill = "white", alpha = 1) +
        scale_shape_manual(values = c(21, 24)) +
        coord_fixed(clip = "off") +
        guides(
            width = guide_legend(order = 1),
            size = guide_legend(order = 2),
            shape = "none", 
            edge_color = "none" 
        )


    dd <- rep(0, length(V(full_graph)$name))

    p <- p + geom_node_text(aes(label = name), size = text_size, nudge_x = p$data$x * .38, nudge_y = p$data$y * .2 + dd, family = "") + # repel = T,check_overlap = T)+
        theme_graph(base_family = "Helvetica") +
        theme(
            legend.text = element_text(size = 9),
            legend.position = "bottom"
        )
    p
}

```


Run CARlasso

```{r}
response = CARlasso(formula_both, data = genus_df, link = "logit", adaptive = TRUE)
```

```{r}
response.horse = horseshoe(response)
```

```{r}
fungi_both_plot = custom_plot_carlasso(response.horse, text_size = 4, repel = TRUE)
fungi_both_plot

ggsave("plot_circular/fungi/fungi_both_plot.pdf", fungi_both_plot, width = 12, height = 10, dpi = 600, device = cairo_pdf, bg = "white", limitsize = FALSE)
```

Single response

```{r}
formula_single = paste(formula, "~ fumigation_status")
formula_single = as.formula(formula_single)
```

```{r}
response2 = CARlasso(formula_single, data = genus_df, link = "logit", adaptive = TRUE)
```

```{r}
response2.horse = horseshoe(response2)
```

```{r}
fungi_single_plot = custom_plot_carlasso(response2.horse, text_size = 4, repel = TRUE)
fungi_single_plot

ggsave("plot_circular/fungi/fungi_single_plot.pdf", fungi_single_plot, width = 12, height = 10, dpi = 600, device = cairo_pdf, bg = "white", limitsize = FALSE)
```

CARlasso on top 10 most different taxa.

```{r}
top10 = difference_df[1:10,]
otus10 = top10$names
otu_quoted10 = paste0("`", otus10, "`")
formula10 = paste(otu_quoted10, collapse = "+")
formula_both10 = paste(formula10, "~ fumigation_status+Treatment")
formula_both10 = as.formula(formula_both10)
```

```{r}
response10 = CARlasso(formula_both10, data = genus_df, link = "logit", adaptive = TRUE)
```

```{r}
response10.horse = horseshoe(response10)
```

```{r}
# save plot
fungi_top10_plot = custom_plot_carlasso(response10.horse, text_size = 4, repel = TRUE)
fungi_top10_plot

ggsave("plot_circular/fungi/fungi_top10_plot.pdf", fungi_top10_plot, width = 12, height = 10, dpi = 600, device = cairo_pdf, bg = "white", limitsize = FALSE)
```


Single response on top 10 most different taxa.

```{r}
formula_single10 = paste(formula10, "~ fumigation_status")
formula_single10 = as.formula(formula_single10)
```

```{r}
response10_single = CARlasso(formula_single10, data = genus_df, link = "logit", adaptive = TRUE)
```

```{r}
response10_single.horse = horseshoe(response10_single)
```

```{r}
fungi_top10_single_plot = custom_plot_carlasso(response10_single.horse, text_size = 4, repel = TRUE)
fungi_top10_single_plot

ggsave("plot_circular/fungi/fungi_top10_single_plot.pdf", fungi_top10_single_plot, width = 12, height = 10, dpi = 600, device = cairo_pdf, bg = "white", limitsize = FALSE)
```



