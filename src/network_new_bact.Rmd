---
title: "Network Analysis New Bacteria"
author: "Tianyi Xu"
date: "2025-03-07"
output: html_document
---

```{r}
#installation in case you need some package
#install.packages(c("igraph", "graphlayouts", "ggraph","ggforce"))
#devtools::install_github("schochastics/networkdata")
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(vegan)
library(tidyverse)
library(here)
library(forcats)
library(compositions)
library(dplyr)
library(stringr)
library(glasso)
library(igraph)
library(qgraph)
library(ggraph)
library(networkdata)
library(graphlayouts)
library(ggforce)
library(ggplot2)
library(CARlasso)
library(viridis)
library(VennDiagram)
library(ggsci)
library(RColorBrewer)
```

Read in the data

```{r}
samp_metadata = readRDS(here("data", "clean", "samp_metadata.RDS"))
bac_abundance = readRDS(here("data", "clean", "bac_abundance.RDS"))
```

Data Preprocessing
    
```{r}
# Aggregate based on families. Choose to look at family OTU.
fam.df = bac_abundance %>% 
  mutate(Family = as.character(Family), Genus = as.character(Genus)) %>%
  mutate(Family = ifelse(Family == "Unknown_Family", Genus, Family)) %>%
  mutate(Family = replace_na(Family, "Unknown")) %>% #Missing values included in Unknown_Family level
  group_by(Family) %>%
  summarise(across(starts_with("Samp"), sum))  

fams = fam.df$Family
fam.mat = as.matrix(fam.df[,-1])
rownames(fam.mat) = fams
fam.mat = fam.mat[rownames(fam.mat)!="Unknown",]
fam.mat = t(fam.mat)

```

Extract the phylum mapping for each family
```{r}
phylum_mapping = bac_abundance %>%
  select(Family, Phylum) %>%
  mutate(Phylum = as.character(Phylum), Family = as.character(Family)) %>%
  mutate(Phylum = replace_na(Phylum, "Unknown")) %>%
  group_by(Family) %>%
  summarise(Phylum = first(Phylum)) %>%
  {setNames(.$Phylum, .$Family)}
```

# Function to create consistent phylum colors
```{r}
# Create a function to generate consistent phylum colors
get_phylum_colors = function(phylum_mapping) {
  # Get all unique phyla
  all_phyla = unique(phylum_mapping)
  all_phyla = all_phyla[!is.na(all_phyla)]
  all_phyla = c(all_phyla, "Unknown_Phylum")
  
  # for base color, use npg palette
  base_colors = pal_npg("nrc")(10)
  
  # if color is more than 10, use colorRampPalette to generate more colors
  n_phyla = length(all_phyla)
  phylum_colors = if(n_phyla > 10) {
    colorRampPalette(base_colors)(n_phyla)
  } else {
    base_colors[1:n_phyla]
  }
  
  # make this mapping
  names(phylum_colors) = all_phyla
  
  return(phylum_colors)
}
```

```{r}
# Generate the global phylum color palette once
global_phylum_colors = get_phylum_colors(phylum_mapping)
```

```{r}
# add sample number to metadata for each samples.
samp_metadata = samp_metadata %>%
  mutate(fumigation = case_when(
    Time == "Day_0" | Treatment == "Non-fumigated chipping grass"  ~ "never",
    Time == "Day_10" & Treatment != "Non-fumigated chipping grass" ~ "recent",
    Time != "Day_0" & Time != "Day_10" & Treatment != "Non-fumigated chipping grass" ~ "past"
  )) %>%
  mutate(sample_name = case_when(
    samp_number < 10 ~ paste0("Samp00", samp_number),
    samp_number < 100 ~ paste0("Samp0", samp_number),
    TRUE ~ paste0("Samp", samp_number)
  ))

```

```{r}
# pull out samples based on fumigation time
never = samp_metadata %>% filter(fumigation == "never") %>% pull(sample_name)
recent = samp_metadata %>% filter(fumigation == "recent") %>% pull(sample_name)
past = samp_metadata %>% filter(fumigation == "past") %>% pull(sample_name)

# create 3 different matrix for 3 fumigation time
fam.mat.never = fam.mat[never,]
fam.mat.recent = fam.mat[recent,]
fam.mat.past = fam.mat[past,]
```

Function for data analysis

```{r}
# create a function to process matrix
create_matrix = function(mat){
    # clr transformation
    mat = mat + 0.5
    mat = clr(mat)

    # correlation matrix
    mat = cor(mat)
    return(mat)
}

glasso_net = function(mat, rho){
    net = glasso(mat, rho = rho)
    p.net = net$wi
    colnames(p.net) = colnames(mat)
    rownames(p.net) = rownames(mat)

    # check if matrix is symmetric
    if (!isSymmetric(p.net)) {
        p.net[lower.tri(p.net)] = t(p.net)[lower.tri(p.net)]
    }

    # calculate partical correlation matrix
    parr.corr.net = matrix(nrow = nrow(p.net), ncol = ncol(p.net))

    for(k in 1:nrow(parr.corr.net)) {
        for(j in 1:ncol(parr.corr.net)) {
        parr.corr.net[j, k] = -p.net[j,k]/sqrt(p.net[j,j]*p.net[k,k])
        }
    }

    colnames(parr.corr.net) = colnames(p.net)
    rownames(parr.corr.net) = rownames(p.net)
    diag(parr.corr.net) = 0

    net.glasso = graph.adjacency(parr.corr.net, mode = "undirected", weighted = TRUE, diag = FALSE)
    return(net.glasso)
}   
```

Set scale_edge_color_discrete

```{r}
set.seed(3407)
```

Plot the network - Glasso

```{r}
# first get transformed matrix
never.mat = create_matrix(fam.mat.never)
recent.mat = create_matrix(fam.mat.recent)
past.mat = create_matrix(fam.mat.past)

never.glasso = glasso_net(never.mat, 0.75)
recent.glasso = glasso_net(recent.mat, 0.75)
past.glasso = glasso_net(past.mat, 0.75)
```

```{r}

# convert glasso weight to positive
E(never.glasso)$positive_weight = E(never.glasso)$weight - (min(E(never.glasso)$weight)) + 0.0001
E(recent.glasso)$positive_weight = E(recent.glasso)$weight - (min(E(recent.glasso)$weight)) + 0.0001
E(past.glasso)$positive_weight = E(past.glasso)$weight - (min(E(past.glasso)$weight)) + 0.0001

# absolute weight
E(never.glasso)$abs_weight = abs(E(never.glasso)$weight)
E(recent.glasso)$abs_weight = abs(E(recent.glasso)$weight)
E(past.glasso)$abs_weight = abs(E(past.glasso)$weight)
```

```{r}
# # compute clustering
# V(never.glasso)$clu = as.character(membership(cluster_louvain(never.glasso)))
# V(recent.glasso)$clu = as.character(membership(cluster_louvain(recent.glasso)))
# V(past.glasso)$clu = as.character(membership(cluster_louvain(past.glasso)))

# compute node size based on degree
V(never.glasso)$size = degree(never.glasso)
V(recent.glasso)$size = degree(recent.glasso)
V(past.glasso)$size = degree(past.glasso)

# V(never.glasso)$clu[V(never.glasso)$degree == 0] = "999"
# V(recent.glasso)$clu[V(recent.glasso)$degree == 0] = "999"
# V(past.glasso)$clu[V(past.glasso)$degree == 0] = "999"
```

```{r}
# Find nodes with a degree of 0 for each graph
zero_degree_nodes_never = V(never.glasso)[degree(never.glasso) == 0]
zero_degree_nodes_recent = V(recent.glasso)[degree(recent.glasso) == 0]
zero_degree_nodes_past = V(past.glasso)[degree(past.glasso) == 0]

# Assign these nodes to a new community cluster (cluster "999")
V(never.glasso)[degree(never.glasso) == 0]$clu = "999"
V(recent.glasso)[degree(recent.glasso) == 0]$clu = "999"
V(past.glasso)[degree(past.glasso) == 0]$clu = "999"
```

Plot the network for Glasso method

Here is the function to create a plot.

```{r}
grouped_circle_layout = function(graph,
                                  group.attr = "phylum",
                                  radius = 1,
                                  start_angle = 0) {
  #graph df
  vdf = as_data_frame(graph, what = "vertices")
  # vertex original index
  vdf$orig_idx = seq_len(nrow(vdf))
  
  # vertex group
  vdf$group = vdf[[group.attr]]
  groups = unique(vdf$group)
  
  # group size
  group_sizes = table(vdf$group)
  total_nodes = sum(group_sizes)
  
  # matrix to store (x,y)
  coords = matrix(NA_real_, nrow = nrow(vdf), ncol = 2,
                   dimnames = list(NULL, c("x", "y")))
  
  # keep track of where the next group's arc should begin
  current_angle = start_angle
  
  # loop over each group and assign it a proportional arc of the circle
  for (g in groups) {
    # indices for nodes of this group
    idx = which(vdf$group == g)
    k   = length(idx)
    
    # fraction of the total circle used by this group
    frac     = k / total_nodes
    arc_len  = 2 * pi * frac
    arc_start = current_angle
    arc_end   = arc_start + arc_len
    
    # evenly distribute this group's k nodes along [arc_start, arc_end]
    if (k == 1) {
      # if only one node in this group, place it at the midpoint of the arc
      angles = (arc_start + arc_end)/2
    } else {
      angles = seq(arc_start, arc_end, length.out = k + 2)
      # drop the first and last angle so nodes don't crowd the boundaries
      angles = angles[-c(1, length(angles))]
    }
    
    # convert polar -> cartesian
    coords[idx, "x"] = radius * cos(angles)
    coords[idx, "y"] = radius * sin(angles)
    
    # update for the next group
    current_angle = arc_end
  }
  
  # create a data frame (x,y) in the correct vertex order
  layout_df = data.frame(x=coords[, "x"], 
                          y=coords[, "y"],
                          orig_idx=vdf$orig_idx)
  layout_df = layout_df[order(layout_df$orig_idx), ]
  layout_df$orig_idx = NULL

  return(layout_df)
}

```

```{r}
# # net: net object, title: title of plot, filter: filter out nodes with degree less than filter
plot_circular_network = function(net, title, phylum_mapping, degree_filter, node_size = 3, edge_threshold = 0.07){
  # filter out edges
    net_filtered = delete_edges(net, which(E(net)$abs_weight <= edge_threshold))
    
    # Use global phylum colors
    # phylum_colors = get_phylum_colors(phylum_mapping)

    # add phylum information to nodes
    V(net_filtered)$phylum = phylum_mapping[V(net_filtered)$name]
    V(net_filtered)$phylum[is.na(V(net_filtered)$phylum)] = "Unknown_Phylum"

    # add edge color with more contrasting colors
    # Light silver-gray for positive (#E0E0E0), darker tan/sand for negative (#D2B48C)
    E(net_filtered)$edge_color = ifelse(E(net_filtered)$weight >= 0, "#BBBBBB", "#D2B48C") 
    # assign edge alpha
    E(net_filtered)$edge_alpha = scales::rescale(E(net_filtered)$abs_weight, to = c(0.3, 0.8))

    # print number of positive and negative edges
    print(paste("Number of positive edges:", sum(E(net_filtered)$weight >= 0)))
    print(paste("Number of negative edges:", sum(E(net_filtered)$weight < 0)))
    layout_df = grouped_circle_layout(net_filtered, group.attr = "phylum")
    layout_data = create_layout(net_filtered, layout = "manual", x = layout_df$x, y = layout_df$y)

    network = ggraph(layout_data) +
    geom_edge_link0(aes(width = weight, alpha = edge_alpha, color = edge_color)) +
    geom_node_point(aes(fill = phylum), shape = 21, size = node_size, stroke = 0.8) +
    geom_node_text(aes(filter = size > degree_filter, label = name, size = 3), family = "serif", repel = TRUE, show.legend = FALSE) +
    scale_edge_width(range = c(0.5, 2.5)) +
    scale_edge_alpha(range = c(0.3, 0.8)) +
    scale_edge_color_identity() +
    scale_fill_manual(values = global_phylum_colors, name = "Phylum") +
    labs(fill = "Phylum") +  # Renames legend titles properly
        guides(
          edge_alpha = "none",
          edge_width = "none",
            fill = guide_legend(title = "Phylum", ncol = 5)
        ) +
    theme_void() +
    theme(
      legend.position = "bottom",
      plot.background = element_rect(fill = "white", color = NA),  # White background for the entire plot
      legend.text = element_text(size = 13, family = "Times New Roman"),
      legend.title = element_text(size = 13, family = "Times New Roman", face = "bold"),
      legend.box = "horizontal",
      legend.margin = margin(t = 10),
      legend.key.size = unit(0.8, "lines")
    )
    return(network)
}
```

We do a little investigation to choose the edge threshold.

```{r}
# Extract edge weights from all three networks
edge_weights_never = E(never.glasso)$abs_weight
edge_weights_recent = E(recent.glasso)$abs_weight
edge_weights_past = E(past.glasso)$abs_weight

# df for edge weights
#all_edge_weights = c(edge_weights_never, edge_weights_recent, edge_weights_past)

edge_weights_never_df = data.frame(weight = edge_weights_never)
edge_weights_recent_df = data.frame(weight = edge_weights_recent)
edge_weights_past_df = data.frame(weight = edge_weights_past)
```

```{r}
# plot the distribution of edge weights for never fumigated samples
ggplot(edge_weights_never_df, aes(x = weight)) +
    geom_histogram(bins = 50, fill = "steelblue", alpha = 0.7) +
    geom_vline(xintercept = quantile(edge_weights_never_df$weight, c(0.75, 0.9, 0.95)), 
               linetype = "dashed", color = "red") +
    theme_minimal() +
    labs(title = "Edge Weight Distribution for Never Fumigated Samples", x = "Edge Weight", y = "Count")
```

```{r}
# plot the distribution of edge weights for recent fumigated samples
ggplot(edge_weights_recent_df, aes(x = weight)) +
    geom_histogram(bins = 50, fill = "steelblue", alpha = 0.7) +
    geom_vline(xintercept = quantile(edge_weights_recent_df$weight, c(0.75, 0.9, 0.95)), 
               linetype = "dashed", color = "red") +
    theme_minimal() +
    labs(title = "Edge Weight Distribution for Recent Fumigated Samples", x = "Edge Weight", y = "Count")
```

```{r}
# plot the distribution of edge weights for past fumigated samples
ggplot(edge_weights_past_df, aes(x = weight)) +
    geom_histogram(bins = 50, fill = "steelblue", alpha = 0.7) +
    geom_vline(xintercept = quantile(edge_weights_past_df$weight, c(0.75, 0.9, 0.95)), 
               linetype = "dashed", color = "red") +
    theme_minimal() +
    labs(title = "Edge Weight Distribution for Past Fumigated Samples", x = "Edge Weight", y = "Count")
```

We choose the threshold for each fumigation time.

We choose 0.9 quantile as the edge threshold.

```{r}
egde_threshold_never = quantile(edge_weights_never_df$weight, 0.95)
egde_threshold_recent = quantile(edge_weights_recent_df$weight, 0.95)
egde_threshold_past = quantile(edge_weights_past_df$weight, 0.95)
print(paste("The edge threshold for never fumigated samples is", egde_threshold_never))
print(paste("The edge threshold for recent fumigated samples is", egde_threshold_recent))
print(paste("The edge threshold for past fumigated samples is", egde_threshold_past))
```

```{r}
# plot the network for glasso

#never
plot.never.glasso = plot_circular_network(never.glasso, "Network for Never Fumigated Samples Using Glasso", phylum_mapping, 99, edge_threshold = egde_threshold_never)
plot.never.glasso

ggsave("plot_circular/bacteria/never_glasso.pdf", plot.never.glasso, width = 10, height = 14, dpi = 600, device = cairo_pdf, bg = "white", limitsize = FALSE)
```


```{r}
# recent
plot.recent.glasso = plot_circular_network(recent.glasso, "Network for Recent Fumigated Samples Using Glasso", phylum_mapping, 99, edge_threshold = egde_threshold_recent)
plot.recent.glasso

ggsave("plot_circular/bacteria/recent_glasso.pdf", plot.recent.glasso, width = 10, height = 14, dpi = 600, device = cairo_pdf, bg = "white", limitsize = FALSE)
```


```{r}
# past
plot.past.glasso = plot_circular_network(past.glasso, "Network for Past Fumigated Samples Using Glasso", phylum_mapping, 99, edge_threshold = egde_threshold_past)
plot.past.glasso

ggsave("plot_circular/bacteria/past_glasso.pdf", plot.past.glasso, width = 10, height = 14, dpi = 600, device = cairo_pdf, bg = "white", limitsize = FALSE)
```


Now, find intersection of edges between the 3 networks.

```{r}
# function to create a venn diagram for 3 networks
create_triple_venn = function(net1, net2, net3, names) {
  # Get edge lists and standardize them
  edges1 = get.edgelist(net1)
  edges2 = get.edgelist(net2)
  edges3 = get.edgelist(net3)
  
  # Sort each edge to ensure consistent representation
  edges1 = t(apply(edges1, 1, sort))
  edges2 = t(apply(edges2, 1, sort))
  edges3 = t(apply(edges3, 1, sort))
  
  # Convert to dataframes for easier comparison
  edges1_df = as.data.frame(edges1)
  edges2_df = as.data.frame(edges2)
  edges3_df = as.data.frame(edges3)
  
  # Create a unique identifier for each edge
  edges1_df$edge_id = paste(edges1_df$V1, edges1_df$V2, sep = "_")
  edges2_df$edge_id = paste(edges2_df$V1, edges2_df$V2, sep = "_")
  edges3_df$edge_id = paste(edges3_df$V1, edges3_df$V2, sep = "_")
  
  # Get unique edge IDs for each network
  edges_set1 = edges1_df$edge_id
  edges_set2 = edges2_df$edge_id
  edges_set3 = edges3_df$edge_id
  
  # Create the Venn diagram
  venn_plot = draw.triple.venn(
    area1 = length(edges_set1),
    area2 = length(edges_set2),
    area3 = length(edges_set3),
    n12 = length(intersect(edges_set1, edges_set2)),
    n23 = length(intersect(edges_set2, edges_set3)),
    n13 = length(intersect(edges_set1, edges_set3)),
    n123 = length(intersect(intersect(edges_set1, edges_set2), edges_set3)),
    category = c(
      paste0(names[1], " (", length(edges_set1), ")"),
      paste0(names[2], " (", length(edges_set2), ")"),
      paste0(names[3], " (", length(edges_set3), ")")
    ),
    fill = c("#1B9E77", "#D95F02", "#7570B3"),
    alpha = 0.5,
    lty = "solid",
    cex = 3.5,
    cat.cex = 2.4,
    cat.dist = 0.05,
    cat.pos = c(0, 0, 180)
  )
  
  return(venn_plot)
}
```

Plot the venn diagram for the 3 networks

```{r}
venn_plot = create_triple_venn(never.glasso, recent.glasso, past.glasso, c("Never", "Recent", "Past"))
grid.draw(venn_plot)
```

```{r}
options(repr.plot.res = 1200)    # Set global resolution to 1200 DPI
par(mar = c(5, 4, 4, 2) + 0.1)  # Adjust margins for high-res output

cairo_pdf(here("plot_circular", "bacteria", "venn_plot.pdf"), 
    width = 12, 
    height = 15,
    family = "ArialMT",
    fallback_resolution = 1200,  # Set DPI to 1200
    onefile = TRUE)
grid.draw(venn_plot)
dev.off()
```

Draw the network for edges in all 3 networks

```{r}
# Function to create and plot a network with edges common to all three networks
plot_common_edges_network = function(net1, net2, net3, title, phylum_mapping, node_size = 10, edge_threshold = 0.07) {
  # Get edge lists and standardize them
  edges1 = get.edgelist(net1)
  edges2 = get.edgelist(net2)
  edges3 = get.edgelist(net3)
  
  # Sort each edge to ensure consistent representation
  edges1 = t(apply(edges1, 1, sort))
  edges2 = t(apply(edges2, 1, sort))
  edges3 = t(apply(edges3, 1, sort))
  
  # Convert to dataframes for easier comparison
  edges1_df = as.data.frame(edges1)
  edges2_df = as.data.frame(edges2)
  edges3_df = as.data.frame(edges3)
  
  # Create a unique identifier for each edge
  edges1_df$edge_id = paste(edges1_df$V1, edges1_df$V2, sep = "_")
  edges2_df$edge_id = paste(edges2_df$V1, edges2_df$V2, sep = "_")
  edges3_df$edge_id = paste(edges3_df$V1, edges3_df$V2, sep = "_")
  
  # Find edges common to all three networks
  common_edges_ids = intersect(intersect(edges1_df$edge_id, edges2_df$edge_id), edges3_df$edge_id)
  
  # Extract the common edges
  common_edges = edges1_df[edges1_df$edge_id %in% common_edges_ids, c("V1", "V2")]
  
  # Create a new graph with only the common edges
  # First, identify all unique nodes in the common edges
  all_nodes = unique(c(common_edges$V1, common_edges$V2))
  
  # Create an empty graph
  common_graph = graph.empty(directed = FALSE, n = length(all_nodes))
  V(common_graph)$name = all_nodes
  
  # Add the common edges
  common_graph = add_edges(common_graph, t(as.matrix(common_edges)))
  
  # Add phylum information to nodes
  V(common_graph)$phylum = phylum_mapping[V(common_graph)$name]
  V(common_graph)$phylum[is.na(V(common_graph)$phylum)] = "Unknown_Phylum"
  
  # Calculate node degree for sizing text
  V(common_graph)$degree = degree(common_graph)

  # Use global phylum colors directly
  # phylum_colors = get_phylum_colors(phylum_mapping)

  # Create the plot
  layout_df = grouped_circle_layout(common_graph, group.attr = "phylum")
  layout_data = create_layout(common_graph, layout = "manual", x = layout_df$x, y = layout_df$y)
  network_plot = ggraph(layout_data) +
    geom_edge_link0(aes(color = "#FDAE61")) +
    geom_node_point(aes(fill = phylum), shape = 21, size = node_size, stroke = 0.8) +
    geom_node_text(aes(label = name, size = 4, x = 1.2*x, y = 1.2*y), 
                  family = "serif", repel = TRUE, show.legend = FALSE) +
    scale_edge_width(range = c(0.5, 2.5)) +
    scale_edge_color_identity() +
    scale_fill_manual(values = global_phylum_colors, name = "Phylum") +
    labs(
        fill = "Phylum") +  # Renames legend titles properly
    guides(
        edge_alpha = "none",
        edge_width = "none",
        fill = guide_legend(title = "Phylum", ncol = 5)
    ) +
    theme_graph() +
    ggtitle(title) +
    theme(
      plot.title = element_text(size = 18, face = "bold", family = "Times", hjust = 0.5),
      legend.position = "bottom",
      legend.title = element_text(size = 13, face = "bold"),
      legend.text = element_text(size = 13),
      legend.box = "horizontal",
      legend.margin = margin(t = 10),
      legend.key.size = unit(0.8, "lines"),
      plot.background = element_rect(fill = "white", color = NA)
    )
  return(list(plot = network_plot, graph = common_graph))
}
```

```{r}
#Now use the function for each fumigation condition
never_common_result = plot_common_edges_network(
  never.glasso, recent.glasso, past.glasso,
  "Subnetwork Shared Among All Three Fumigation Status",
  phylum_mapping
)

# Display the plot
never_common_result$plot

# Save the plot
ggsave("plot_circular/bacteria/never_common_edges.pdf", 
       never_common_result$plot, 
       width = 10, height = 14, dpi = 600, 
       device = cairo_pdf, bg = "white", limitsize = FALSE)

```

Now, unique edges in each network.

```{r}
# Optimized function to create and plot networks with edges unique to each method
plot_unique_edges_network = function(net1, net2, net3, method_names, title, phylum_mapping, node_size = 10) {
  # Get edge lists and standardize them
  edges1 = get.edgelist(net1)
  edges2 = get.edgelist(net2)
  edges3 = get.edgelist(net3)
  
  # Sort each edge to ensure consistent representation
  edges1 = t(apply(edges1, 1, sort))
  edges2 = t(apply(edges2, 1, sort))
  edges3 = t(apply(edges3, 1, sort))
  
  # Convert to dataframes for easier comparison
  edges1_df = as.data.frame(edges1)
  edges2_df = as.data.frame(edges2)
  edges3_df = as.data.frame(edges3)
  
  # Create a unique identifier for each edge
  edges1_df$edge_id = paste(edges1_df$V1, edges1_df$V2, sep = "_")
  edges2_df$edge_id = paste(edges2_df$V1, edges2_df$V2, sep = "_")
  edges3_df$edge_id = paste(edges3_df$V1, edges3_df$V2, sep = "_")
  
  # Add weights to the edge dataframes
  edges1_df$weight = E(net1)$weight
  edges2_df$weight = E(net2)$weight
  edges3_df$weight = E(net3)$weight

  # add absolute weight
  edges1_df$abs_weight = abs(edges1_df$weight)
  edges2_df$abs_weight = abs(edges2_df$weight)
  edges3_df$abs_weight = abs(edges3_df$weight)
  
  # Find edges unique to each network
  unique_edges1 = setdiff(edges1_df$edge_id, union(edges2_df$edge_id, edges3_df$edge_id))
  unique_edges2 = setdiff(edges2_df$edge_id, union(edges1_df$edge_id, edges3_df$edge_id))
  unique_edges3 = setdiff(edges3_df$edge_id, union(edges1_df$edge_id, edges2_df$edge_id))
  
  # Create a list to store the three networks
  unique_networks = list()
  plots = list()
  
  # Colors for each method
  method_colors = c("#1B9E77", "#D95F02", "#7570B3")
  
  # Process each network
  for (i in 1:3) {
    # Get the appropriate unique edges
    if (i == 1) {
      unique_edges = unique_edges1
      edges_df = edges1_df
    } else if (i == 2) {
      unique_edges = unique_edges2
      edges_df = edges2_df
    } else {
      unique_edges = unique_edges3
      edges_df = edges3_df
    }
    
    # Skip if no unique edges
    if (length(unique_edges) == 0) {
      unique_networks[[i]] = NULL
      plots[[i]] = NULL
      next
    }
    
    # Extract edges and weights
    unique_edges_df = edges_df[edges_df$edge_id %in% unique_edges, ]
    
    # Filter by weight threshold
    # dynamic edge threshold
    edge_threshold = quantile(unique_edges_df$abs_weight, 0.9)
    unique_edges_df = unique_edges_df[unique_edges_df$abs_weight > edge_threshold, ]
    
    # Skip if no edges after filtering
    if (nrow(unique_edges_df) == 0) {
      unique_networks[[i]] = NULL
      plots[[i]] = NULL
      next
    }
    
    # Create a new graph with only the unique edges
    all_nodes = unique(c(unique_edges_df$V1, unique_edges_df$V2))
    
    # Create an empty graph
    unique_graph = graph.empty(directed = FALSE, n = length(all_nodes))
    V(unique_graph)$name = all_nodes
    
    # Add the unique edges with weights
    for (j in 1:nrow(unique_edges_df)) {
      unique_graph = add_edges(
        unique_graph, 
        c(unique_edges_df$V1[j], unique_edges_df$V2[j]),
        weight = unique_edges_df$weight[j]
      )
    }
    
    # Add phylum information to nodes
    V(unique_graph)$phylum = phylum_mapping[V(unique_graph)$name]
    V(unique_graph)$phylum[is.na(V(unique_graph)$phylum)] = "Unknown_Phylum"
    
    # Calculate node degree for sizing text
    V(unique_graph)$degree = degree(unique_graph)
    
    # Store the graph
    unique_networks[[i]] = unique_graph

    # Assign edge colors
    E(unique_graph)$edge_color = ifelse(E(unique_graph)$weight > 0, "#BBBBBB", "#D2B48C")

    # print number of positive and negative edges
    print(paste("Number of positive edges:", sum(E(unique_graph)$weight > 0)))
    print(paste("Number of negative edges:", sum(E(unique_graph)$weight < 0)))
   
    E(unique_graph)$edge_alpha = scales::rescale(E(unique_graph)$weight, to = c(0.3, 0.8))

    layout_df = grouped_circle_layout(unique_graph, group.attr = "phylum")
    layout_data = create_layout(unique_graph, layout = "manual", x = layout_df$x, y = layout_df$y)
    
    # Create the plot
    network_plot = ggraph(layout_data) +
      geom_edge_link0(aes(width = weight, alpha = edge_alpha, color = edge_color)) +
      scale_edge_width(range = c(0.2, 3)) +
      scale_edge_alpha(range = c(0.3, 0.8)) +
      scale_edge_color_identity() +
      geom_node_point(aes(fill = phylum), shape = 21, size = node_size, stroke = 0.8) +
      geom_node_text(aes(label = name, size = 3, x = 1.2*x, y = 1.2*y), 
                    family = "serif", repel = TRUE, show.legend = FALSE) +
      scale_fill_manual(values = global_phylum_colors, name = "Phylum") +
      labs(
           fill = "Phylum") +  
      guides(
        edge_alpha = "none",
        edge_width = "none",
        fill = guide_legend(title = "Phylum", ncol = 5)
      ) +
      theme_graph() +
      ggtitle(paste0("Subnetwork Specific to ", method_names[i], " Fumigation Status")) +
      theme(
        plot.title = element_text(size = 16, hjust = 0.5, family = "Times"),
        legend.position = "bottom",
        legend.title = element_text(size = 13, face = "bold", family = "Times"),
        legend.text = element_text(size = 13, family = "Times"),
        legend.box = "horizontal",
        legend.margin = margin(t = 10),
        legend.key.size = unit(0.8, "lines"),
        plot.background = element_rect(fill = "white", color = NA)
      )
    
    plots[[i]] = network_plot
  }
  
  return(list(plots = plots, graphs = unique_networks))
}
```

Plot the unique networks

```{r}

# Now use the function for each fumigation condition
# For never fumigated samples
unique_result = plot_unique_edges_network(
  never.glasso, recent.glasso, past.glasso,
  c("Never", "Recent", "Past"),
  "Subnetwork Specific to Each Fumigation Status",
  phylum_mapping
)
```

```{r}
# Display and save the plots
for (i in 1:3) {
  if (!is.null(unique_result$plots[[i]])) {
    print(unique_result$plots[[i]])
    method_name = c("Never", "Recent", "Past")[i]
    ggsave(paste0("plot_circular/bacteria/never_unique_", method_name, ".pdf"), 
           unique_result$plots[[i]], 
           width = 10, height = 14, dpi = 600, 
           device = cairo_pdf, bg = "white", limitsize = FALSE)
  }
}
```



# Function specifically for recent networks with selective node labeling based on edge weight
```{r}
plot_recent_unique_networks = function(net1, net2, net3, method_names, title, phylum_mapping, node_size = 10, 
                                      edge_label_threshold = 0.95, weight_threshold = 0.95) {
  # same processing as in plot_unique_edges_network
  edges1 = get.edgelist(net1)
  edges2 = get.edgelist(net2)
  edges3 = get.edgelist(net3)
  
  edges1 = t(apply(edges1, 1, sort))
  edges2 = t(apply(edges2, 1, sort))
  edges3 = t(apply(edges3, 1, sort))
  
  edges1_df = as.data.frame(edges1)
  edges2_df = as.data.frame(edges2)
  edges3_df = as.data.frame(edges3)
  
  edges1_df$edge_id = paste(edges1_df$V1, edges1_df$V2, sep = "_")
  edges2_df$edge_id = paste(edges2_df$V1, edges2_df$V2, sep = "_")
  edges3_df$edge_id = paste(edges3_df$V1, edges3_df$V2, sep = "_")
  
  edges1_df$weight = E(net1)$weight
  edges2_df$weight = E(net2)$weight
  edges3_df$weight = E(net3)$weight

  edges1_df$abs_weight = abs(edges1_df$weight)
  edges2_df$abs_weight = abs(edges2_df$weight)
  edges3_df$abs_weight = abs(edges3_df$weight)
  
  unique_edges1 = setdiff(edges1_df$edge_id, union(edges2_df$edge_id, edges3_df$edge_id))
  unique_edges2 = setdiff(edges2_df$edge_id, union(edges1_df$edge_id, edges3_df$edge_id))
  unique_edges3 = setdiff(edges3_df$edge_id, union(edges1_df$edge_id, edges2_df$edge_id))
  
  unique_networks = list()
  plots = list()
  
  method_colors = c("#1B9E77", "#D95F02", "#7570B3")
  
  # recent network (i=2)
  i = 2
  unique_edges = unique_edges2
  edges_df = edges2_df
    
  # Skip if no unique edges
  if (length(unique_edges) == 0) {
    return(NULL)
  }
    
  # Extract edges and weights
  unique_edges_df = edges_df[edges_df$edge_id %in% unique_edges, ]
    
  # Filter by weight threshold (using parameter)
  edge_threshold = quantile(unique_edges_df$abs_weight, weight_threshold)
  unique_edges_df = unique_edges_df[unique_edges_df$abs_weight > edge_threshold, ]
    
  # Skip if no edges after filtering
  if (nrow(unique_edges_df) == 0) {
    return(NULL)
  }
    
  # Create a new graph with only the unique edges
  all_nodes = unique(c(unique_edges_df$V1, unique_edges_df$V2))
    
  # Create an empty graph
  unique_graph = graph.empty(directed = FALSE, n = length(all_nodes))
  V(unique_graph)$name = all_nodes
    
  # Add the unique edges with weights
  for (j in 1:nrow(unique_edges_df)) {
    unique_graph = add_edges(
      unique_graph, 
      c(unique_edges_df$V1[j], unique_edges_df$V2[j]),
      weight = unique_edges_df$weight[j],
      abs_weight = unique_edges_df$abs_weight[j]
    )
  }
    
    # Add phylum information to nodes
    V(unique_graph)$phylum = phylum_mapping[V(unique_graph)$name]
    V(unique_graph)$phylum[is.na(V(unique_graph)$phylum)] = "Unknown_Phylum"
    
    # Calculate node degree for sizing text
    V(unique_graph)$degree = degree(unique_graph)
    
    # Calculate the edge weight threshold for labeling
    label_threshold = quantile(E(unique_graph)$abs_weight, edge_label_threshold)
   
    # Identify nodes connected to edges above the label threshold
    nodes_to_label = c()
    for (e in E(unique_graph)) {
      if (E(unique_graph)[e]$abs_weight >= label_threshold) {
        nodes_to_label = c(nodes_to_label, ends(unique_graph, e))
      }
    }
    nodes_to_label = unique(as.vector(nodes_to_label))
    
    # Set the show_label property for each node
    V(unique_graph)$show_label = V(unique_graph)$name %in% nodes_to_label
    
    # Store the graph
    unique_networks[[i]] = unique_graph

    # Assign edge colors
    E(unique_graph)$edge_color = ifelse(E(unique_graph)$weight > 0, "#BBBBBB", "#D2B48C")

    # print summary statistics
    print(paste("Number of nodes:", length(V(unique_graph))))
    print(paste("Number of nodes with labels:", sum(V(unique_graph)$show_label)))
    print(paste("Edge weight threshold for labels:", label_threshold))
    print(paste("Number of positive edges:", sum(E(unique_graph)$weight > 0)))
    print(paste("Number of negative edges:", sum(E(unique_graph)$weight < 0)))
   
    E(unique_graph)$edge_alpha = scales::rescale(abs(E(unique_graph)$weight), to = c(0.3, 0.8))

    layout_df = grouped_circle_layout(unique_graph, group.attr = "phylum")
    layout_data = create_layout(unique_graph, layout = "manual", x = layout_df$x, y = layout_df$y)
    
    # Create the plot - only show labels for nodes connected to edges above threshold
    network_plot = ggraph(layout_data) +
      geom_edge_link0(aes(width = abs(weight), alpha = edge_alpha, color = edge_color)) +
      scale_edge_width(range = c(0.2, 3)) +
      scale_edge_alpha(range = c(0.3, 0.8)) +
      scale_edge_color_identity() +
      geom_node_point(aes(fill = phylum), shape = 21, size = node_size, stroke = 0.8) +
      # Only show labels for nodes that meet the criteria
      geom_node_text(aes(label = ifelse(show_label, name, ""), size = 3, x = 1.2*x, y = 1.2*y), 
                    family = "serif", repel = TRUE, show.legend = FALSE) +
      scale_fill_manual(values = global_phylum_colors, name = "Phylum") +
      labs(
           fill = "Phylum") +  
      guides(
        edge_alpha = "none",
        edge_width = "none",
        fill = guide_legend(title = "Phylum", ncol = 4)
      ) +
      theme_graph() +
      ggtitle(paste0("Subnetwork Specific to ", method_names[i], " Fumigation Status")) +
      theme(
        plot.title = element_text(size = 16, hjust = 0.5, family = "Times"),
        legend.position = "bottom",
        legend.title = element_text(size = 13, face = "bold", family = "Times"),
        legend.text = element_text(size = 13, family = "Times"),
        legend.box = "horizontal",
        legend.margin = margin(t = 10),
        legend.key.size = unit(0.8, "lines"),
        plot.background = element_rect(fill = "white", color = NA)
      )
    
    return(network_plot)
}
```

```{r}


# Final plot with chosen threshold (can be adjusted after reviewing the above)
final_threshold = 0.90  # Adjust based on the results from above

final_recent_plot = plot_recent_unique_networks(
  never.glasso, recent.glasso, past.glasso,
  c("Never", "Recent", "Past"),
  "Subnetwork Specific to Recent Fumigation",
  phylum_mapping,
  node_size = 10,
  edge_label_threshold = final_threshold,
  weight_threshold = 0.90
)

# Display the final plot
print(final_recent_plot)

# Save the final plot
ggsave("plot_circular/bacteria/recent_unique_final.pdf", 
       final_recent_plot, 
       width = 10, height = 14, dpi = 600, 
       device = cairo_pdf, bg = "white", limitsize = FALSE)
```


Now, Identify Different nodes/taxas in 3 network.

```{r}
# degree and betweenness centrality
degree.never = degree(never.glasso)
degree.recent = degree(recent.glasso)
degree.past = degree(past.glasso)

# convert weights to shifted positive weights (-min)
E(never.glasso)$true_weights = E(never.glasso)$weight
E(recent.glasso)$true_weights = E(recent.glasso)$weight
E(past.glasso)$true_weights = E(past.glasso)$weight
```


```{r}
E(never.glasso)$weight = E(never.glasso)$positive_weight
E(recent.glasso)$weight = E(recent.glasso)$positive_weight
E(past.glasso)$weight = E(past.glasso)$positive_weight

betweenness.never = betweenness(never.glasso)
betweenness.recent = betweenness(recent.glasso)
betweenness.past = betweenness(past.glasso)
```

```{r}
# df
degree_df = data.frame(
  fumigation = c(rep("never", length(degree.never)), rep("recent", length(degree.recent)), rep("past", length(degree.past))),
  degree = c(degree.never, degree.recent, degree.past)
)

betweenness_df = data.frame(
  fumigation = c(rep("never", length(betweenness.never)), rep("recent", length(betweenness.recent)), rep("past", length(betweenness.past))),
  betweenness = c(betweenness.never, betweenness.recent, betweenness.past)
)
```

Plot the degree and betweenness centrality

```{r}
# degree
dg_boxplot = ggplot(degree_df, aes(x = fumigation, y = degree)) +
  geom_boxplot() +
  theme_minimal() +
  labs(x = "Fumigation Status", y = "Degree Distribution", title = "Glasso Network") +
  theme(
    plot.title = element_text(size = 25, hjust = 0.5),  # Increase the size of the plot title
    axis.title.x = element_text(size = 20, margin = margin(t = 15)),  # Increase the size of the x-axis title
    axis.title.y = element_text(size = 30, margin = margin(r = 15)),  # Increase the size of the y-axis title
    axis.text.x = element_text(size = 25),  # Increase the size of the x-axis labels
    axis.text.y = element_text(size = 25)   # Increase the size of the y-axis labels
  )

dg_boxplot

ggsave("plot_circular/bacteria/dg_boxplot.pdf", dg_boxplot, width = 12, height = 10, dpi = 600, device = cairo_pdf, bg = "white", limitsize = FALSE)
```

```{r}
# betweenness
bt_boxplot = ggplot(betweenness_df, aes(x = fumigation, y = betweenness)) +
  geom_boxplot() +
  theme_minimal() +
  labs(x = "Fumigation Status", y = "Betweenness Distribution", title = "Glasso Network") +
  theme(
    plot.title = element_text(size = 25, hjust = 0.5),  # Increase the size of the plot title
    axis.title.x = element_text(size = 20, margin = margin(t = 15)),  # Increase the size of the x-axis title
    axis.title.y = element_text(size = 30, margin = margin(r = 15)),  # Increase the size of the y-axis title
    axis.text.x = element_text(size = 25),  # Increase the size of the x-axis labels
    axis.text.y = element_text(size = 25)   # Increase the size of the y-axis labels
  )

bt_boxplot

ggsave("plot_circular/bacteria/bt_boxplot.pdf", bt_boxplot, width = 12, height = 10, dpi = 600, device = cairo_pdf, bg = "white", limitsize = FALSE)
```


Let's find the 20 most different one

```{r}
# degree
degree_difference = abs(degree.never - degree.recent) + abs(degree.never - degree.past) + abs(degree.recent - degree.past)
betweeness_difference = abs(betweenness.never - betweenness.recent) + abs(betweenness.never - betweenness.past) + abs(betweenness.recent - betweenness.past)

difference_df = data.frame(
  names = names(degree_difference),
  degree_difference = degree_difference,
  betweeness_difference = betweeness_difference
)


difference_df$score = difference_df$degree_difference + difference_df$betweeness_difference

difference_df = difference_df[order(difference_df$score, decreasing = TRUE),]

top_20 = difference_df[1:20,]

top_20$names
```

Here is the names of the top 20 different nodes.

Now, we fit carlasso model to 20 taxas.

```{r}
never_fumigated = samp_metadata %>% 
  filter(fumigation == "never") %>%
  pull(sample_name)

recent_fumigated = samp_metadata %>%
  filter(fumigation == "recent") %>%
  pull(sample_name)

past_fumigated = samp_metadata %>%
  filter(fumigation == "past") %>%
  pull(sample_name)

fam_df = as.data.frame(fam.mat)
fam_df = fam_df %>%
  mutate(sample_name = rownames(fam_df)) %>%
  mutate(fumigation_status = case_when(
    sample_name %in% never_fumigated ~ "never",
    sample_name %in% recent_fumigated ~ "recent",
    sample_name %in% past_fumigated ~ "past"
  ))
fam_df$Treatment = samp_metadata$Treatment

otus = top_20$names
otu_quoted = paste0("`", otus, "`")
formula = paste(otu_quoted, collapse = "+")
formula_both = paste(formula, "~ fumigation_status+Treatment")
formula_both = as.formula(formula_both)
```

```{r}
# carlasso plot function, from sourcecode of CARlasso package

get_CAR_MB <- function(B, Omega) {
  D <- diag(diag(Omega))
  R <- D - Omega

  return(list(
    M = diag(1 / diag(Omega)),
    C = t(solve(D, R)), B = t(solve(D, t(B)))
  ))
}

custom_plot_carlasso <- function(x, text_size = 15, ...) {
    dots <- list(...)
    tol <- dots$tol
    if(x$settings$link=="logit"){
        response_name <- x$nodes$response[-length(x$nodes$response)]
    }
    else{
        response_name <- x$nodes$response
    }
    if(is.null(tol)) tol = 0.01
    col_pn <- c("lightblue","pink")
    # graph structure using threshold:
    if(is.null(x$horseshoe_binary)){
        B_binary <- abs(x$point_est$beta) > tol
        Graph_binary <- abs(x$point_est$Omega) > tol
    }
    else {
        B_binary <- x$horseshoe_binary$B_binary
        Graph_binary <- x$horseshoe_binary$Omega_binary
    }
    diag(Graph_binary) <- 1
    CAR <- get_CAR_MB(x$point_est$beta*B_binary,
        Graph_binary*x$point_est$Omega)
    
    n_resp <- length(response_name)
    n_pred <- length(x$nodes$predictors)

    vertices_df <- data.frame(id = c(paste0("resp", 1:n_resp), 
        paste0("pred", 1:n_pred)),
        group = c(rep("resp", n_resp),
        rep("pred", n_pred)))

    ind_mat_resp <- expand.grid(from = 1:n_resp, to = 1:n_resp)
    ind_mat_resp <- ind_mat_resp[ind_mat_resp$from != ind_mat_resp$to, ]
    ind_mat_resp$weight <- sapply(1:nrow(ind_mat_resp),
            function(i, indmat, mat) {
                mat[indmat$from[i], indmat$to[i]]
            }
        ,ind_mat_resp, CAR$C)

    ind_mat_pred <- expand.grid(from = 1:n_pred, to = 1:n_resp)
    ind_mat_pred$weight <- sapply(1:nrow(ind_mat_pred), 
            function(i, indmat, mat) {
                mat[indmat$from[i], indmat$to[i]]
            }
        , ind_mat_pred, CAR$B)

    ind_mat_pred$from <- paste0("pred", ind_mat_pred$from)
    ind_mat_pred$to <- paste0("resp", ind_mat_pred$to)
    ind_mat_resp$from <- paste0("resp", ind_mat_resp$from)
    ind_mat_resp$to <- paste0("resp", ind_mat_resp$to)

    edge_df <- rbind(ind_mat_resp, ind_mat_pred)
    edge_df <- edge_df[edge_df$weight != 0, ]

    edge_abs_df <- edge_df
    edge_abs_df$weight <- abs(edge_abs_df$weight)

    full_graph <- graph.data.frame(edge_df, vertices_df, directed = T)


    col_ER <- c("orange", "darkgreen")
    shape_ER <- c("square", "circle")
    type <- c("predictors", "microbe")
    direction <- c("negative", "positive")

    E(full_graph)$edge.color <- col_pn[(sign(E(full_graph)$weight) + 1) / 2 + 1]
    E(full_graph)$direction. <- direction[(sign(E(full_graph)$weight) + 1) / 2 + 1]
    E(full_graph)$abs_weight <- abs(E(full_graph)$weight)


    V(full_graph)$name <- c(response_name, x$nodes$predictors)

    V(full_graph)$alpha_centrality <- alpha_centrality(full_graph)
    V(full_graph)$type <- type[c(rep(2, n_resp), rep(1, n_pred))]

    cbPalette_edge <- c("#0072B2", "#990000")
    cbPalette_node <- c("#0815d3", "#682d01")

    set_graph_style(plot_margin = margin(10, 10, 10, 10))
    p <- ggraph(full_graph, layout = "circle") 
    
    if(length(unique(E(full_graph)$direction.))==1){
        p <- p + geom_edge_link(aes(
            width = abs_weight, alpha = abs_weight), 
            color = ifelse(E(full_graph)$direction.[1]=="positive",cbPalette_edge[2], cbPalette_edge[1]))
    }
    else {
       p <- p + geom_edge_link(aes(color = direction.,
            width = abs_weight, alpha = abs_weight)) +
        scale_edge_color_manual(values = (cbPalette_edge))
    }
    
    p <-  p +
        geom_node_point(mapping = aes(shape = type,
                size = alpha_centrality, stroke = 1.5),
            col = "#000000", fill = "white", alpha = 1) +
        scale_shape_manual(values = c(21, 24)) +
        coord_fixed(clip = "off") +
        guides(
            width = guide_legend(order = 1),
            size = guide_legend(order = 2),
            shape = "none", 
            edge_color = "none" 
        )


    dd <- rep(0, length(V(full_graph)$name))

    p <- p + geom_node_text(aes(label = name), size = text_size, nudge_x = p$data$x * .38, nudge_y = p$data$y * .2 + dd, family = "") + # repel = T,check_overlap = T)+
        theme_graph(base_family = "Helvetica") +
        theme(
            legend.text = element_text(size = 9),
            legend.position = "bottom"
        )
    p
}

```

Run CARlasso

```{r}
response = CARlasso(formula_both, data = fam_df, link = "logit", adaptive = TRUE)
```

```{r}
response.horse = horseshoe(response)
```

```{r}
bact_both_plot = custom_plot_carlasso(response.horse, text_size = 4, repel = TRUE)

bact_both_plot

ggsave("plot_circular/bacteria/bact_both_plot.pdf", bact_both_plot, width = 12, height = 10, dpi = 600, device = cairo_pdf, bg = "white", limitsize = FALSE)
```

Single response

```{r}
formula_single = paste(formula, "~ fumigation_status")
formula_single = as.formula(formula_single)
```

```{r}
response2 = CARlasso(formula_single, data = fam_df, link = "logit", adaptive = TRUE)
```

```{r}
response2.horse = horseshoe(response2)
```

```{r}
bact_single_plot = custom_plot_carlasso(response2.horse, text_size = 4, repel = TRUE)

bact_single_plot

ggsave("plot_circular/bacteria/bact_single_plot.pdf", bact_single_plot, width = 12, height = 10, dpi = 600, device = cairo_pdf, bg = "white", limitsize = FALSE)
```

CARlasso on top 10 most different taxa.

```{r}
top10 = difference_df[1:10,]
otus10 = top10$names
otu_quoted10 = paste0("`", otus10, "`")
formula10 = paste(otu_quoted10, collapse = "+")
formula_both10 = paste(formula10, "~ fumigation_status+Treatment")
formula_both10 = as.formula(formula_both10)
```

```{r}
response10 = CARlasso(formula_both10, data = fam_df, link = "logit", adaptive = TRUE)
```

```{r}
response10.horse = horseshoe(response10)
```

```{r}
# save plot
bact_top10_plot = custom_plot_carlasso(response10.horse, text_size = 4, repel = TRUE)

bact_top10_plot

ggsave("plot_circular/bacteria/bact_top10_plot.pdf", bact_top10_plot, width = 12, height = 10, dpi = 600, device = cairo_pdf, bg = "white", limitsize = FALSE)
```


Single response on top 10 most different taxa.

```{r}
formula_single10 = paste(formula10, "~ fumigation_status")
formula_single10 = as.formula(formula_single10)
```

```{r}
response10_single = CARlasso(formula_single10, data = fam_df, link = "logit", adaptive = TRUE)
```

```{r}
response10_single.horse = horseshoe(response10_single)
```

```{r}
bact_top10_single_plot = custom_plot_carlasso(response10_single.horse, text_size = 4, repel = TRUE)

bact_top10_single_plot

ggsave("plot_circular/bacteria/bact_top10_single_plot.pdf", bact_top10_single_plot, width = 12, height = 10, dpi = 600, device = cairo_pdf, bg = "white", limitsize = FALSE)
```
