---
title: "Network Analysis New Bacteria"
author: "Tianyi Xu"
date: "2025-03-07"
output: html_document
---

```{r}
#installation in case you need some package
#install.packages(c("igraph", "graphlayouts", "ggraph","ggforce"))
#devtools::install_github("schochastics/networkdata")
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(vegan)
library(tidyverse)
library(here)
library(forcats)
library(compositions)
library(dplyr)
library(stringr)
library(glasso)
library(igraph)
library(qgraph)
library(ggraph)
library(networkdata)
library(graphlayouts)
library(ggforce)
library(ggplot2)
library(CARlasso)
library(viridis)
library(VennDiagram)
library(ggsci)
library(RColorBrewer)
```

Read in the data

```{r}
samp_metadata = readRDS(here("data", "clean", "samp_metadata.RDS"))
bac_abundance = readRDS(here("data", "clean", "bac_abundance.RDS"))
```

Data Preprocessing
    
```{r}
# Aggregate based on families. Choose to look at family OTU.
fam.df = bac_abundance %>% 
  mutate(Family = as.character(Family), Genus = as.character(Genus)) %>%
  mutate(Family = ifelse(Family == "Unknown_Family", Genus, Family)) %>%
  mutate(Family = replace_na(Family, "Unknown")) %>% #Missing values included in Unknown_Family level
  group_by(Family) %>%
  summarise(across(starts_with("Samp"), sum))  

fams = fam.df$Family
fam.mat = as.matrix(fam.df[,-1])
rownames(fam.mat) = fams
fam.mat = fam.mat[rownames(fam.mat)!="Unknown",]
fam.mat = t(fam.mat)

```

Extract the phylum mapping for each family
```{r}
phylum_mapping = bac_abundance %>%
  select(Family, Phylum) %>%
  mutate(Phylum = as.character(Phylum), Family = as.character(Family)) %>%
  mutate(Phylum = replace_na(Phylum, "Unknown")) %>%
  group_by(Family) %>%
  summarise(Phylum = first(Phylum)) %>%
  {setNames(.$Phylum, .$Family)}
```

```{r}
# add sample number to metadata for each samples.
samp_metadata = samp_metadata %>%
  mutate(fumigation = case_when(
    Time == "Day_0" | Treatment == "Non-fumigated chipping grass"  ~ "never",
    Time == "Day_10" & Treatment != "Non-fumigated chipping grass" ~ "recent",
    Time != "Day_0" & Time != "Day_10" & Treatment != "Non-fumigated chipping grass" ~ "past"
  )) %>%
  mutate(sample_name = case_when(
    samp_number < 10 ~ paste0("Samp00", samp_number),
    samp_number < 100 ~ paste0("Samp0", samp_number),
    TRUE ~ paste0("Samp", samp_number)
  ))

```

```{r}
# pull out samples based on fumigation time
never = samp_metadata %>% filter(fumigation == "never") %>% pull(sample_name)
recent = samp_metadata %>% filter(fumigation == "recent") %>% pull(sample_name)
past = samp_metadata %>% filter(fumigation == "past") %>% pull(sample_name)

# create 3 different matrix for 3 fumigation time
fam.mat.never = fam.mat[never,]
fam.mat.recent = fam.mat[recent,]
fam.mat.past = fam.mat[past,]
```

Function for data analysis

```{r}
# create a function to process matrix
create_matrix = function(mat){
    # clr transformation
    mat = mat + 0.5
    mat = clr(mat)

    # correlation matrix
    mat = cor(mat)
    return(mat)
}

glasso_net = function(mat, rho){
    net = glasso(mat, rho = rho)
    p.net = net$wi
    colnames(p.net) = colnames(mat)
    rownames(p.net) = rownames(mat)

    # check if matrix is symmetric
    if (!isSymmetric(p.net)) {
        p.net[lower.tri(p.net)] = t(p.net)[lower.tri(p.net)]
    }

    # calculate partical correlation matrix
    parr.corr.net = matrix(nrow = nrow(p.net), ncol = ncol(p.net))

    for(k in 1:nrow(parr.corr.net)) {
        for(j in 1:ncol(parr.corr.net)) {
        parr.corr.net[j, k] = -p.net[j,k]/sqrt(p.net[j,j]*p.net[k,k])
        }
    }

    colnames(parr.corr.net) = colnames(p.net)
    rownames(parr.corr.net) = rownames(p.net)
    diag(parr.corr.net) = 0

    net.glasso = graph.adjacency(parr.corr.net, mode = "undirected", weighted = TRUE, diag = FALSE)
    return(net.glasso)
}   
```

Set scale_edge_color_discrete

```{r}
set.seed(3407)
```

Plot the network - Glasso

```{r}
# first get transformed matrix
never.mat = create_matrix(fam.mat.never)
recent.mat = create_matrix(fam.mat.recent)
past.mat = create_matrix(fam.mat.past)

never.glasso = glasso_net(never.mat, 0.75)
recent.glasso = glasso_net(recent.mat, 0.75)
past.glasso = glasso_net(past.mat, 0.75)

# convert glasso weight to positive
E(never.glasso)$weight = E(never.glasso)$weight - (min(E(never.glasso)$weight)) + 0.0001
E(recent.glasso)$weight = E(recent.glasso)$weight - (min(E(recent.glasso)$weight)) + 0.0001
E(past.glasso)$weight = E(past.glasso)$weight - (min(E(past.glasso)$weight)) + 0.0001

# compute clustering
V(never.glasso)$clu = as.character(membership(cluster_louvain(never.glasso)))
V(recent.glasso)$clu = as.character(membership(cluster_louvain(recent.glasso)))
V(past.glasso)$clu = as.character(membership(cluster_louvain(past.glasso)))

# compute node size based on degree
V(never.glasso)$size = degree(never.glasso)
V(recent.glasso)$size = degree(recent.glasso)
V(past.glasso)$size = degree(past.glasso)

V(never.glasso)$clu[V(never.glasso)$degree == 0] = "999"
V(recent.glasso)$clu[V(recent.glasso)$degree == 0] = "999"
V(past.glasso)$clu[V(past.glasso)$degree == 0] = "999"
```

```{r}
# Find nodes with a degree of 0 for each graph
zero_degree_nodes_never = V(never.glasso)[degree(never.glasso) == 0]
zero_degree_nodes_recent = V(recent.glasso)[degree(recent.glasso) == 0]
zero_degree_nodes_past = V(past.glasso)[degree(past.glasso) == 0]

# Assign these nodes to a new community cluster (cluster "999")
V(never.glasso)[degree(never.glasso) == 0]$clu = "999"
V(recent.glasso)[degree(recent.glasso) == 0]$clu = "999"
V(past.glasso)[degree(past.glasso) == 0]$clu = "999"
```

Plot the network for Glasso method

Here is the function to create a plot.

```{r}
# net: net object, title: title of plot, filter: filter out nodes with degree less than filter
plot_circular_network = function(net, title, phylum_mapping,degree_filter, node_size = 3, edge_threshold = 0.07){
  # filter out edges
    net_filtered = delete_edges(net, which(E(net)$weight <= edge_threshold))
    
    base_colors = pal_npg("nrc")(10)
    phylum_colors = colorRampPalette(base_colors)(27)  # Repeat for 27 phyla

    # add phylum information to nodes
    V(net_filtered)$phylum = phylum_mapping[V(net_filtered)$name]
    V(net_filtered)$phylum[is.na(V(net_filtered)$phylum)] = "Unknown_Phylum"

    E(net_filtered)$edge_color = sapply(1:ecount(net_filtered), function(i) {
    edge_ends = ends(net_filtered, i)
    node1_phylum = V(net_filtered)$phylum[match(edge_ends[1], V(net_filtered)$name)]
    node2_phylum = V(net_filtered)$phylum[match(edge_ends[2], V(net_filtered)$name)]
    
    # Get phylum color indices
    index1 = match(node1_phylum, unique(V(net_filtered)$phylum))
    index2 = match(node2_phylum, unique(V(net_filtered)$phylum))
    
    # Handle missing values
    if(is.na(index1)) index1 = 1
    if(is.na(index2)) index2 = 1
    
    # Get colors of both nodes
    color1 = col2rgb(phylum_colors[index1])
    color2 = col2rgb(phylum_colors[index2])
    
    # Compute average color
    avg_color = rgb((color1[1] + color2[1]) / 2 / 255, 
                    (color1[2] + color2[2]) / 2 / 255, 
                    (color1[3] + color2[3]) / 2 / 255)
    
    return(avg_color)
    })
    E(net_filtered)$edge_alpha = scales::rescale(E(net_filtered)$weight, to = c(0.3, 0.8))

    network = ggraph(net_filtered, layout = "circle") +
    geom_edge_link0(aes(width = weight, alpha = edge_alpha, color = edge_color)) +
    geom_node_point(aes(fill = phylum), shape = 21, size = node_size, stroke = 0.8) +
    geom_node_text(aes(filter = size > degree_filter, label = name, size = 3), family = "serif", repel = TRUE, show.legend = FALSE) +
    scale_edge_width(range = c(0.5, 2.5)) +
    scale_edge_alpha(range = c(0.3, 0.8)) +
    scale_edge_color_identity() +
    #scale_size(range = c(1, 6)) +
    #scale_fill_viridis(discrete = TRUE, option = "viridis", name = "phylum") +
    scale_fill_manual(values = phylum_colors, name = "Phylum") +
    labs(edge_alpha = "Edge Transparency", 
             width = "Edge Weight",
             fill = "Phylum") +  # Renames legend titles properly
        guides(
            edge_alpha = guide_legend(title = "Edge Alpha"),
            edge_width = guide_legend(title = "Weight"),
            fill = guide_legend(title = "Phylum")
        ) +
    theme_void() +
    theme(
      legend.position = "right",
      plot.background = element_rect(fill = "white", color = NA),  # White background for the entire plot
      legend.text = element_text(size = 10, family = "Times New Roman"),
      legend.title = element_text(size = 12, family = "Times New Roman", face = "bold")
    )
    return(network)
}
```

We do a little investigation to choose the edge threshold.

```{r}
# Extract edge weights from all three networks
edge_weights_never = E(never.glasso)$weight
edge_weights_recent = E(recent.glasso)$weight
edge_weights_past = E(past.glasso)$weight

# Combine all edge weights into one vector
all_edge_weights = c(edge_weights_never, edge_weights_recent, edge_weights_past)

edge_weights_df = data.frame(weight = all_edge_weights)

ggplot(edge_weights_df, aes(x = weight)) +
    geom_histogram(bins = 50, fill = "steelblue", alpha = 0.7) +
    geom_vline(xintercept = quantile(all_edge_weights, c(0.75, 0.9, 0.95)), 
               linetype = "dashed", color = "red") +
    theme_minimal() +
    labs(title = "Combined Edge Weight Distribution", x = "Edge Weight", y = "Count")
```

```{r}
# print the quantile of edge weights
quantile(all_edge_weights, c(0.75, 0.9, 0.95))
```

We choose 0.9 quantile as the edge threshold.

```{r}
egde_threshold_global = quantile(all_edge_weights, 0.9)
print(paste("The global edge threshold is", egde_threshold_global))
```

```{r}
# plot the network for glasso

#never
plot.never.glasso = plot_circular_network(never.glasso, "Network for Never Fumigated Samples Using Glasso", phylum_mapping, 99, edge_threshold = egde_threshold_global)
plot.never.glasso

ggsave("plot_circular/bacteria/never_glasso.pdf", plot.never.glasso, width = 12, height = 10, dpi = 600, device = cairo_pdf, bg = "white", limitsize = FALSE)
```


```{r}
# recent
plot.recent.glasso = plot_circular_network(recent.glasso, "Network for Recent Fumigated Samples Using Glasso", phylum_mapping, 99, edge_threshold = egde_threshold_global)
plot.recent.glasso

ggsave("plot_circular/bacteria/recent_glasso.pdf", plot.recent.glasso, width = 12, height = 10, dpi = 600, device = cairo_pdf, bg = "white", limitsize = FALSE)
```


```{r}
# past
plot.past.glasso = plot_circular_network(past.glasso, "Network for Past Fumigated Samples Using Glasso", phylum_mapping, 99, edge_threshold = egde_threshold_global)
plot.past.glasso

ggsave("plot_circular/bacteria/past_glasso.pdf", plot.past.glasso, width = 12, height = 10, dpi = 600, device = cairo_pdf, bg = "white", limitsize = FALSE)
```


Now, find intersection of edges between the 3 networks.

```{r}
# function to create a venn diagram for 3 networks
create_triple_venn = function(net1, net2, net3, names) {
  # Get edge lists and standardize them
  edges1 = get.edgelist(net1)
  edges2 = get.edgelist(net2)
  edges3 = get.edgelist(net3)
  
  # Sort each edge to ensure consistent representation
  edges1 = t(apply(edges1, 1, sort))
  edges2 = t(apply(edges2, 1, sort))
  edges3 = t(apply(edges3, 1, sort))
  
  # Convert to dataframes for easier comparison
  edges1_df = as.data.frame(edges1)
  edges2_df = as.data.frame(edges2)
  edges3_df = as.data.frame(edges3)
  
  # Create a unique identifier for each edge
  edges1_df$edge_id = paste(edges1_df$V1, edges1_df$V2, sep = "_")
  edges2_df$edge_id = paste(edges2_df$V1, edges2_df$V2, sep = "_")
  edges3_df$edge_id = paste(edges3_df$V1, edges3_df$V2, sep = "_")
  
  # Get unique edge IDs for each network
  edges_set1 = edges1_df$edge_id
  edges_set2 = edges2_df$edge_id
  edges_set3 = edges3_df$edge_id
  
  # Create the Venn diagram
  venn_plot = draw.triple.venn(
    area1 = length(edges_set1),
    area2 = length(edges_set2),
    area3 = length(edges_set3),
    n12 = length(intersect(edges_set1, edges_set2)),
    n23 = length(intersect(edges_set2, edges_set3)),
    n13 = length(intersect(edges_set1, edges_set3)),
    n123 = length(intersect(intersect(edges_set1, edges_set2), edges_set3)),
    category = c(
      paste0(names[1], " (", length(edges_set1), ")"),
      paste0(names[2], " (", length(edges_set2), ")"),
      paste0(names[3], " (", length(edges_set3), ")")
    ),
    fill = c("#1B9E77", "#D95F02", "#7570B3"),
    alpha = 0.5,
    lty = "solid",
    cex = 1.5,
    cat.cex = 1.2,
    cat.dist = 0.05,
    cat.pos = c(0, 0, 180)
  )
  
  return(venn_plot)
}
```

Plot the venn diagram for the 3 networks

```{r}
venn_plot = create_triple_venn(never.glasso, recent.glasso, past.glasso, c("Never", "Recent", "Past"))
grid.draw(venn_plot)
```

```{r}
options(repr.plot.res = 1200)    # Set global resolution to 1200 DPI
par(mar = c(5, 4, 4, 2) + 0.1)  # Adjust margins for high-res output

cairo_pdf(here("plot_circular", "venn_plot.pdf"), 
    width = 12, 
    height = 15,
    family = "ArialMT",
    fallback_resolution = 1200,  # Set DPI to 1200
    onefile = TRUE)
grid.draw(venn_plot)
dev.off()
```

Draw the network for edges in all 3 networks

```{r}
# Function to create and plot a network with edges common to all three networks
plot_common_edges_network = function(net1, net2, net3, title, phylum_mapping, node_size = 10, edge_threshold = 0.07) {
  # Get edge lists and standardize them
  edges1 = get.edgelist(net1)
  edges2 = get.edgelist(net2)
  edges3 = get.edgelist(net3)
  
  # Sort each edge to ensure consistent representation
  edges1 = t(apply(edges1, 1, sort))
  edges2 = t(apply(edges2, 1, sort))
  edges3 = t(apply(edges3, 1, sort))
  
  # Convert to dataframes for easier comparison
  edges1_df = as.data.frame(edges1)
  edges2_df = as.data.frame(edges2)
  edges3_df = as.data.frame(edges3)
  
  # Create a unique identifier for each edge
  edges1_df$edge_id = paste(edges1_df$V1, edges1_df$V2, sep = "_")
  edges2_df$edge_id = paste(edges2_df$V1, edges2_df$V2, sep = "_")
  edges3_df$edge_id = paste(edges3_df$V1, edges3_df$V2, sep = "_")
  
  # Find edges common to all three networks
  common_edges_ids = intersect(intersect(edges1_df$edge_id, edges2_df$edge_id), edges3_df$edge_id)
  
  # Extract the common edges
  common_edges = edges1_df[edges1_df$edge_id %in% common_edges_ids, c("V1", "V2")]
  
  # Create a new graph with only the common edges
  # First, identify all unique nodes in the common edges
  all_nodes = unique(c(common_edges$V1, common_edges$V2))
  
  # Create an empty graph
  common_graph = graph.empty(directed = FALSE, n = length(all_nodes))
  V(common_graph)$name = all_nodes
  
  # Add the common edges
  common_graph = add_edges(common_graph, t(as.matrix(common_edges)))
  
  # Add phylum information to nodes
  V(common_graph)$phylum = phylum_mapping[V(common_graph)$name]
  V(common_graph)$phylum[is.na(V(common_graph)$phylum)] = "Unknown_Phylum"
  
  # Calculate node degree for sizing text
  V(common_graph)$degree = degree(common_graph)

  # filter out edges with weight less than edge_threshold
  #common_graph = delete_edges(common_graph, which(E(common_graph)$weight <= edge_threshold))

  base_colors = pal_npg("nrc")(10)
  phylum_colors = colorRampPalette(base_colors)(10)


  #Assign edge colors by blending both connected node colors
  E(common_graph)$edge_color = sapply(1:ecount(common_graph), function(i) {
    edge_ends = ends(common_graph, i)
    node1_phylum = V(common_graph)$phylum[match(edge_ends[1], V(common_graph)$name)]
    node2_phylum = V(common_graph)$phylum[match(edge_ends[2], V(common_graph)$name)]

    # Get phylum color indices
    index1 = match(node1_phylum, unique(V(common_graph)$phylum))
    index2 = match(node2_phylum, unique(V(common_graph)$phylum))

    # Handle missing indices
    if (is.na(index1)) index1 = 1
    if (is.na(index2)) index2 = 1

    # Get colors for both nodes
    color1 = col2rgb(phylum_colors[index1])
    color2 = col2rgb(phylum_colors[index2])
    
    # Compute blended color
    avg_color = rgb((color1[1] + color2[1]) / 2 / 255, 
                    (color1[2] + color2[2]) / 2 / 255, 
                    (color1[3] + color2[3]) / 2 / 255)
    
    return(avg_color)
  })
  #E(common_graph)$edge_alpha = scales::rescale(E(common_graph)$weight, to = c(0.3, 0.8))
  # Create the plot
  network_plot = ggraph(common_graph, layout = "circle") +
    geom_edge_link0(aes(color = edge_color)) +
    geom_node_point(aes(fill = phylum), shape = 21, size = node_size, stroke = 0.8) +
    geom_node_text(aes(label = name, size = 5, x = 1.1*x, y = 1.1*y, repel = TRUE), 
                  family = "serif", repel = TRUE, show.legend = FALSE) +
    #scale_size(range = c(2, 5)) +
    #scale_fill_viridis(discrete = TRUE, option = "viridis", name = "Phylum") +
    scale_edge_width(range = c(0.5, 2.5)) +
    #scale_edge_alpha(range = c(0.3, 0.8)) +
    scale_edge_color_identity() +
    scale_fill_manual(values = phylum_colors, name = "Phylum") +
    labs(edge_alpha = "Edge Transparency", 
             width = "Edge Weight",
             fill = "Phylum") +  # Renames legend titles properly
    guides(
        edge_alpha = guide_legend(title = "Edge Alpha"),
        edge_width = guide_legend(title = "Weight"),
        fill = guide_legend(title = "Phylum")
    ) +
    theme_graph() +
    ggtitle(title) +
    theme(
      plot.title = element_text(size = 18, face = "bold", family = "Times", hjust = 0.5),
      legend.position = "right",
      legend.title = element_text(size = 12, face = "bold"),
      legend.text = element_text(size = 10),
      plot.background = element_rect(fill = "white", color = NA)
    )
  return(list(plot = network_plot, graph = common_graph))
}
```

```{r}
#Now use the function for each fumigation condition
never_common_result = plot_common_edges_network(
  never.glasso, recent.glasso, past.glasso,
  "Common Edges Across All Three Glasso Networks",
  phylum_mapping
)

# Display the plot
never_common_result$plot

# Save the plot
ggsave("plot_circular/bacteria/never_common_edges.pdf", 
       never_common_result$plot, 
       width = 12, height = 10, dpi = 600, 
       device = cairo_pdf, bg = "white", limitsize = FALSE)

```

Now, unique edges in each network.

```{r}
# Optimized function to create and plot networks with edges unique to each method
plot_unique_edges_network = function(net1, net2, net3, method_names, title, phylum_mapping, node_size = 10, edge_threshold = 0.07) {
  # Get edge lists and standardize them
  edges1 = get.edgelist(net1)
  edges2 = get.edgelist(net2)
  edges3 = get.edgelist(net3)
  
  # Sort each edge to ensure consistent representation
  edges1 = t(apply(edges1, 1, sort))
  edges2 = t(apply(edges2, 1, sort))
  edges3 = t(apply(edges3, 1, sort))
  
  # Convert to dataframes for easier comparison
  edges1_df = as.data.frame(edges1)
  edges2_df = as.data.frame(edges2)
  edges3_df = as.data.frame(edges3)
  
  # Create a unique identifier for each edge
  edges1_df$edge_id = paste(edges1_df$V1, edges1_df$V2, sep = "_")
  edges2_df$edge_id = paste(edges2_df$V1, edges2_df$V2, sep = "_")
  edges3_df$edge_id = paste(edges3_df$V1, edges3_df$V2, sep = "_")
  
  # Add weights to the edge dataframes
  edges1_df$weight = E(net1)$weight
  edges2_df$weight = E(net2)$weight
  edges3_df$weight = E(net3)$weight
  
  # Find edges unique to each network
  unique_edges1 = setdiff(edges1_df$edge_id, union(edges2_df$edge_id, edges3_df$edge_id))
  unique_edges2 = setdiff(edges2_df$edge_id, union(edges1_df$edge_id, edges3_df$edge_id))
  unique_edges3 = setdiff(edges3_df$edge_id, union(edges1_df$edge_id, edges2_df$edge_id))
  
  # Create a list to store the three networks
  unique_networks = list()
  plots = list()
  
  # Colors for each method
  method_colors = c("#1B9E77", "#D95F02", "#7570B3")
  
  # Process each network
  for (i in 1:3) {
    # Get the appropriate unique edges
    if (i == 1) {
      unique_edges = unique_edges1
      edges_df = edges1_df
    } else if (i == 2) {
      unique_edges = unique_edges2
      edges_df = edges2_df
    } else {
      unique_edges = unique_edges3
      edges_df = edges3_df
    }
    
    # Skip if no unique edges
    if (length(unique_edges) == 0) {
      unique_networks[[i]] = NULL
      plots[[i]] = NULL
      next
    }
    
    # Extract edges and weights
    unique_edges_df = edges_df[edges_df$edge_id %in% unique_edges, ]
    
    # Filter by weight threshold
    unique_edges_df = unique_edges_df[unique_edges_df$weight > edge_threshold, ]
    
    # Skip if no edges after filtering
    if (nrow(unique_edges_df) == 0) {
      unique_networks[[i]] = NULL
      plots[[i]] = NULL
      next
    }
    
    # Create a new graph with only the unique edges
    all_nodes = unique(c(unique_edges_df$V1, unique_edges_df$V2))
    
    # Create an empty graph
    unique_graph = graph.empty(directed = FALSE, n = length(all_nodes))
    V(unique_graph)$name = all_nodes
    
    # Add the unique edges with weights
    for (j in 1:nrow(unique_edges_df)) {
      unique_graph = add_edges(
        unique_graph, 
        c(unique_edges_df$V1[j], unique_edges_df$V2[j]),
        weight = unique_edges_df$weight[j]
      )
    }
    
    # Add phylum information to nodes
    V(unique_graph)$phylum = phylum_mapping[V(unique_graph)$name]
    V(unique_graph)$phylum[is.na(V(unique_graph)$phylum)] = "Unknown_Phylum"
    
    # Calculate node degree for sizing text
    V(unique_graph)$degree = degree(unique_graph)
    
    # Store the graph
    unique_networks[[i]] = unique_graph

    base_colors = pal_npg("nrc")(10)
    # calculate the number of unique phylums
    unique_phylums_num = length(unique(V(unique_graph)$phylum))
    phylum_colors = colorRampPalette(base_colors)(unique_phylums_num)

    # Assign edge colors by blending node phylum colors
    E(unique_graph)$edge_color = sapply(1:ecount(unique_graph), function(k) {
      edge_ends = ends(unique_graph, k, names = TRUE)
      
      node1_phylum = V(unique_graph)$phylum[match(edge_ends[1], V(unique_graph)$name)]
      node2_phylum = V(unique_graph)$phylum[match(edge_ends[2], V(unique_graph)$name)]
      
      # Handle missing values
      if (is.na(node1_phylum)) node1_phylum = "Unknown_Phylum"
      if (is.na(node2_phylum)) node2_phylum = "Unknown_Phylum"
      
      # Get phylum color indices
      index1 = match(node1_phylum, unique(V(unique_graph)$phylum))
      index2 = match(node2_phylum, unique(V(unique_graph)$phylum))
      
      # Handle missing indices
      if (is.na(index1)) index1 = 1
      if (is.na(index2)) index2 = 1
      
      # Get colors of both nodes
      color1 = col2rgb(phylum_colors[index1])
      color2 = col2rgb(phylum_colors[index2])
      
      # Compute average color
      avg_color = rgb((color1[1] + color2[1]) / 2 / 255, 
                      (color1[2] + color2[2]) / 2 / 255, 
                      (color1[3] + color2[3]) / 2 / 255)
      
      return(avg_color)
    })

    E(unique_graph)$edge_alpha = scales::rescale(E(unique_graph)$weight, to = c(0.3, 0.8))
    
    # Create the plot
    network_plot = ggraph(unique_graph, layout = "circle") +
      geom_edge_link0(aes(width = weight, alpha = edge_alpha, color = edge_color)) +
      scale_edge_width(range = c(0.2, 3)) +
      scale_edge_alpha(range = c(0.3, 0.8)) +
      scale_edge_color_identity() +
      geom_node_point(aes(fill = phylum), shape = 21, size = node_size, stroke = 0.8) +
      geom_node_text(aes(label = name, size = 4, x = 1.1*x, y = 1.1*y, repel = TRUE), 
                    family = "serif", repel = TRUE, show.legend = FALSE) +
      #scale_size(range = c(2, 5)) +
      scale_fill_manual(values = phylum_colors, name = "Phylum") +
      labs(edge_alpha = "Edge Transparency", 
           width = "Edge Weight",
           fill = "Phylum") +  
      guides(
        edge_alpha = guide_legend(title = "Edge Transparency"),
        edge_width = guide_legend(title = "Weight"),
        fill = guide_legend(title = "Phylum")
      ) +
      theme_graph() +
      ggtitle(paste0("Edges Unique to ", method_names[i])) +
      theme(
        plot.title = element_text(size = 16, hjust = 0.5),
        legend.position = "right",
        legend.title = element_text(size = 12, face = "bold", family = "Times"),
        legend.text = element_text(size = 10, family = "Times"),
        plot.background = element_rect(fill = "white", color = NA)
      )
    
    plots[[i]] = network_plot
  }
  
  return(list(plots = plots, graphs = unique_networks))
}
```

Plot the unique networks

```{r}

# Now use the function for each fumigation condition
# For never fumigated samples
unique_result = plot_unique_edges_network(
  never.glasso, recent.glasso, past.glasso,
  c("Never", "Recent", "Past"),
  "Edges Unique to Each Fumigation Condition",
  phylum_mapping
)
```

```{r}
# Display and save the plots
for (i in 1:3) {
  if (!is.null(unique_result$plots[[i]])) {
    print(unique_result$plots[[i]])
    method_name = c("Never", "Recent", "Past")[i]
    ggsave(paste0("plot_circular/bacteria/never_unique_", method_name, ".pdf"), 
           unique_result$plots[[i]], 
           width = 12, height = 10, dpi = 600, 
           device = cairo_pdf, bg = "white", limitsize = FALSE)
  }
}
```